<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vim快速入门</title>
      <link href="/vim/vim%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/52e805df7a4e/"/>
      <url>/vim/vim%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/52e805df7a4e/</url>
      
        <content type="html"><![CDATA[<h2 id="一、vim-命令常用选项"><a href="#一、vim-命令常用选项" class="headerlink" title="一、vim 命令常用选项"></a>一、vim 命令常用选项</h2><ul><li>查看 <code>vim</code> 版本、配置文件位置及编译信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim --version</span><br></pre></td></tr></table></figure><ul><li>打开或新编辑</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim             # 直接开始编辑(保存文件时需指定文件名)</span><br><span class="line">vim &lt;filename&gt;  # 打开已有文件或为新文件指定文件名(文件未保存时文件还不存在)</span><br><span class="line">vim &lt;filelist&gt;  # 打开多个文件</span><br></pre></td></tr></table></figure><ul><li>打开 <code>vim</code> 使用教程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimtutor</span><br></pre></td></tr></table></figure><h2 id="二、vim-的几种模式"><a href="#二、vim-的几种模式" class="headerlink" title="二、vim 的几种模式"></a>二、vim 的几种模式</h2><ul><li><strong>命令模式(Command mode)</strong>: 进入 <code>vim</code> 编辑器默认为此模式, 在该模式下, 键入的字符会被识别为命令</li><li><strong>插入模式(Insert mode)</strong>: 插入模式可以像其他编辑器一样插入字符, 进入插入模式底部会显示 <code>-- INSERT --</code></li><li><strong>底线模式(Last line mode)</strong>: 在命令模式下键入 <code>:</code> 进入底线命令模式, 会在最底部出现 <code>:</code>, 此时可以输入行命令</li><li><strong>视图模式(Visual mode)</strong>: 命令模式下键入 <code>v</code> 进入视图模式, 进入视图模式底部会显示 <code>-- VISUAL --</code>, 在此模式下可以移动光标对文本进行选中, 可以对选中的文本进行命令操作</li></ul><h2 id="三、vim-的基本使用"><a href="#三、vim-的基本使用" class="headerlink" title="三、vim 的基本使用"></a>三、vim 的基本使用</h2><blockquote><p>以下，<code>&lt;filename&gt;</code> 代表文件名, <code>&lt;text&gt;</code> 代表文本, <code>&lt;N&gt;</code> 代表一个数字, <code>&lt;char&gt;</code> 代表一个字符</p></blockquote><h3 id="退出-vim-编辑器"><a href="#退出-vim-编辑器" class="headerlink" title="退出 vim 编辑器"></a>退出 <code>vim</code> 编辑器</h3><ul><li>在未改动文件的情况下: <code>:q</code></li><li>在改动过文件但未保存时: <code>:q!</code>(强制退出)</li></ul><h3 id="从命令模式到插入模式的几种方式"><a href="#从命令模式到插入模式的几种方式" class="headerlink" title="从命令模式到插入模式的几种方式"></a>从命令模式到插入模式的几种方式</h3><ul><li>在光标前: <code>i</code></li><li>在光标后: <code>a</code></li><li>光标下一行: <code>o</code></li><li>光标上一行: <code>O</code></li><li>光标所在行尾部: <code>A</code></li></ul><h3 id="从插入模式返回到命令模式"><a href="#从插入模式返回到命令模式" class="headerlink" title="从插入模式返回到命令模式"></a>从插入模式返回到命令模式</h3><ul><li><code>ESC</code></li><li><code>&lt;ctrl-[&gt;</code></li><li><code>&lt;ctrl-c&gt;</code></li></ul><h3 id="保存相关"><a href="#保存相关" class="headerlink" title="保存相关"></a>保存相关</h3><ul><li>文件存在或文件不存在但已指定文件名: <code>:w</code></li><li>还原文件到上一次保存的状态: <code>:e!</code></li><li>保存并退出<ul><li><code>:wq</code></li><li><code>:x</code></li><li><code>ZZ</code>(命令模式下)</li></ul></li><li>文件不存在且未指定文件名<ul><li><code>:w &lt;filename&gt;</code></li><li><code>:wq &lt;filename&gt;</code></li><li><code>x &lt;filename&gt;</code></li></ul></li></ul><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><ul><li>左下右上分别为: <code>h</code>, <code>j</code>, <code>k</code>, <code>l</code></li><li>移动到行首: <code>0</code></li><li>移动到行尾: <code>$</code></li><li>移动到行首第一个非空白符: <code>^</code></li><li>移动到行尾第一个非空白符: <code>g_</code></li><li>移动到下一个单词的开头: <code>w</code></li><li>移动到下一个单词的结尾: <code>e</code></li><li>移动到下一个单词的开头(紧挨在一起的非空白符识别为一个单词): <code>W</code></li><li>移动到下一个单词的结尾(紧挨在一起的非空白符识别为一个单词): <code>E</code></li><li>移动到相应代码块的对应括号: <code>%</code></li><li>移动到光标所在行内查找到的字符的前一个字符, 向右查找: <code>t&lt;char&gt;</code></li><li>移动到光标所在行内查找到的字符的前一个字符, 向左查找: <code>T&lt;char&gt;</code></li></ul><h3 id="删除相关"><a href="#删除相关" class="headerlink" title="删除相关"></a>删除相关</h3><ul><li>删除当前光标所指字符: <code>x</code></li><li>在本行内删除所有内容, 直到遇到指定字符: <code>dt&lt;char&gt;</code></li></ul><h3 id="查看帮助文档"><a href="#查看帮助文档" class="headerlink" title="查看帮助文档"></a>查看帮助文档</h3><ul><li>进入帮助文档: <code>:help</code></li><li>退出帮助文档, 返回编辑器: <code>:q</code></li><li>退出帮助文档同时退出编辑器: <code>qa!</code></li></ul><h3 id="查找定位"><a href="#查找定位" class="headerlink" title="查找定位"></a>查找定位</h3><ul><li>向下查找: <code>/&lt;text&gt;</code></li><li>向上查找: <code>?&lt;text&gt;</code></li><li>下一个: <code>n</code></li><li>上一个: <code>N</code></li><li>完整匹配光标当前所在的单词并查找下一个: <code>*</code></li><li>完整匹配光标当前所在的单词并查找上一个: <code>#</code></li><li>在光标所在行内查找字符, 向右查找: <code>f&lt;char&gt;</code></li><li>在光标所在行内查找字符, 向左查找: <code>F&lt;char&gt;</code></li><li>查找高亮: <code>:set hlsearch</code></li></ul><blockquote><p>编辑器下方的 <code>/text</code> 或 <code>?text</code> 未消失说明还在查找状态, 在查找状态可选择查找下一个或上一个</p></blockquote><h3 id="撤销与重做"><a href="#撤销与重做" class="headerlink" title="撤销与重做"></a>撤销与重做</h3><ul><li>撤销上一次操作: <code>u</code></li><li>还原上一次撤销的操作: <code>&lt;ctrl-r&gt;</code></li></ul><h3 id="复制相关"><a href="#复制相关" class="headerlink" title="复制相关"></a>复制相关</h3><ul><li>复制光标所在行: <code>yy</code></li><li>剪切光标所在行: <code>dd</code></li><li>在光标下一行插入一行并粘贴: <code>p</code></li><li>将下一行的内容合并到本行: <code>J</code></li></ul><h3 id="对原有命令进行附加操作"><a href="#对原有命令进行附加操作" class="headerlink" title="对原有命令进行附加操作"></a>对原有命令进行附加操作</h3><ul><li>重复上一个改变文本的命令: <code>.</code></li><li>重复某个命令 <code>N</code> 次: <code>N&lt;command&gt;</code></li><li>重复 <code>N</code> 次插入操作: <code>Ni&lt;text&gt;&lt;ctrl-c&gt;&lt;CR&gt;</code></li></ul><h3 id="跳转相关"><a href="#跳转相关" class="headerlink" title="跳转相关"></a>跳转相关</h3><ul><li>跳转到第 <code>N</code> 行<ul><li><code>&lt;N&gt;G</code></li><li><code>:&lt;N&gt;</code></li></ul></li><li>跳转到第一行: <code>gg</code></li><li>跳转到最后一行: <code>G</code></li></ul><h2 id="四、vim-进阶使用"><a href="#四、vim-进阶使用" class="headerlink" title="四、vim 进阶使用"></a>四、vim 进阶使用</h2><h3 id="视图模式"><a href="#视图模式" class="headerlink" title="视图模式"></a>视图模式</h3><p>以字符为选择单位, 命令模式下键入 <code>v</code> 进入视图模式, 进入视图模式底部会显示 <code>-- VISUAL --</code></p><ul><li>选择双引号之间的内容, 但不包括引号本身: <code>vi&quot;</code></li><li>选择双引号之间的内容, 包括引号本身: <code>va&quot;</code></li><li>选择括号之间的内容, 但不包括括号本身: <code>vi)</code></li><li>选择括号之间的内容, 包括括号本身: <code>va)&quot;</code></li><li>… (只要是成对的符号都可以这样操作)</li></ul><h3 id="行视图模式"><a href="#行视图模式" class="headerlink" title="行视图模式"></a>行视图模式</h3><p>以行作为选择单位, 在命令模式下键入 <code>V</code> 进入行视图模式, 进入行视图模式底部会显示 <code>-- VISUAL LINE --</code></p><h3 id="块视图模式"><a href="#块视图模式" class="headerlink" title="块视图模式"></a>块视图模式</h3><p>可以进行矩形(块)选择, <code>&lt;ctrl-v&gt;</code> 进入块视图模式, 进入块视图模式底部会显示 <code>-- VISUAL BLOCK --</code></p><ul><li>在块视图模式下键入 <code>I</code> 可以进入块插入模式, 可以对选择的块以行为单位进行批量插入</li></ul><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><p>在插入模式下, 键入<code>&lt;ctrl-n&gt;</code>, <code>ctrl-p</code> 可以进行自动补全, <code>&lt;ctrl-n&gt;</code> 为选中下一个补全项, <code>&lt;ctrl-p&gt;</code> 为选中上一个补全项</p><h3 id="快速缩进"><a href="#快速缩进" class="headerlink" title="快速缩进"></a>快速缩进</h3><p>进入视图模式后, 可以键入 <code>=</code> 将选中的内容自动缩进</p><h3 id="多文件与分屏"><a href="#多文件与分屏" class="headerlink" title="多文件与分屏"></a>多文件与分屏</h3><ul><li>上下分屏: <code>:sp</code></li><li>左右分屏: <code>:vs</code></li><li>在不同的分屏中跳转: <code>&lt;ctrl-w&gt;*2</code></li><li>在本分屏中载入文件: <code>:b &lt;filename&gt;</code></li></ul><h2 id="五、vim-的配置文件"><a href="#五、vim-的配置文件" class="headerlink" title="五、vim 的配置文件"></a>五、vim 的配置文件</h2><h3 id="不同配置文件的位置与区别"><a href="#不同配置文件的位置与区别" class="headerlink" title="不同配置文件的位置与区别"></a>不同配置文件的位置与区别</h3><ul><li>系统配置文件: <code>/etc/.vimrc</code></li><li>用户配置文件: <code>~/.vimrc</code></li></ul><blockquote><p>注意: 系统配置文件对所有用户生效, 用户配置文件仅对当前用户生效, 用户配置文件对于当前用户来说优先级较高, 所以在系统配置文件中我们一般只设置公共配置或不进行配置</p></blockquote><h2 id="六、vim-常用配置"><a href="#六、vim-常用配置" class="headerlink" title="六、vim 常用配置"></a>六、vim 常用配置</h2><h3 id="视觉相关"><a href="#视觉相关" class="headerlink" title="视觉相关"></a>视觉相关</h3><ul><li>显示行号: <code>set number</code></li><li>查找高亮: <code>set hlsearch</code></li><li>成对匹配的符号高亮: <code>set showmatch</code></li><li>当前行高亮: <code>set cursorline</code></li><li>列高亮: <code>set colorcolumn=82</code>(个人习惯 82)</li></ul><h3 id="缩进相关"><a href="#缩进相关" class="headerlink" title="缩进相关"></a>缩进相关</h3><ul><li>自动缩进: <code>set autoindent</code></li><li>根据文件其他地方推测一个 tab 为几个空格: <code>set starttab</code></li><li>缩进量: <code>set shiftwidth=2</code></li><li>缩进及退格所缩进或删除的空格数: <code>set softtabstop=2</code></li><li>使用空格缩进: <code>set expandtab</code></li></ul><h3 id="查找相关"><a href="#查找相关" class="headerlink" title="查找相关"></a>查找相关</h3><ul><li>查找时忽略大小写: <code>set ignorecase</code></li><li>输入搜索时就高亮显示: <code>set incsearch</code></li></ul><h2 id="七、vim-安装插件"><a href="#七、vim-安装插件" class="headerlink" title="七、vim 安装插件"></a>七、vim 安装插件</h2><h3 id="安装-coc-nvim"><a href="#安装-coc-nvim" class="headerlink" title="安装 coc.nvim"></a>安装 coc.nvim</h3><p>暂未开始</p><h2 id="到此还未结束-本文档将不定时更新"><a href="#到此还未结束-本文档将不定时更新" class="headerlink" title="到此还未结束, 本文档将不定时更新"></a>到此还未结束, 本文档将不定时更新</h2><p><strong><em>written by jm</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的命名空间</title>
      <link href="/CPP/CPP%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/d563b29f47f2/"/>
      <url>/CPP/CPP%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/d563b29f47f2/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是命名空间"><a href="#什么是命名空间" class="headerlink" title="什么是命名空间"></a>什么是命名空间</h2><p>命名空间是用于表示一组标识符的可见范围，用于解决标识符重定义的问题。</p><h2 id="命名空间的使用"><a href="#命名空间的使用" class="headerlink" title="命名空间的使用"></a>命名空间的使用</h2><h3 id="例子引入"><a href="#例子引入" class="headerlink" title="例子引入"></a>例子引入</h3><p>我们正在进行多人开发或大项目开发时，可能会出现标识符重定义的问题，也就是变量名、函数名、类名可能会存在重复的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file_a.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello. I am JM&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SayHello</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file_b.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello. I am AA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到 <code>file_a.cpp</code> 和 <code>file_b.cpp</code> 中同时出现了同名函数且不构成函数重载。</p><p>如果我们此时进行编译的话会不通过，会出现链接错误并提示你: <strong>duplicate symbols</strong>。</p><p>虽然这个例子举得可能不恰当，似乎并不会有人这样做，但是相信我，你一定会出现类似问题的，这也是命名空间存在的意义。</p></blockquote><h3 id="命名空间的语法"><a href="#命名空间的语法" class="headerlink" title="命名空间的语法"></a>命名空间的语法</h3><ul><li>声明一个命名空间</li></ul><p><code>namespace 命名空间名 &#123; /\* some identifiers \*/ &#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>访问命名空间中的内容</li></ul><p><code>命名空间名::标识符</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; ns::a &lt;&lt; std::endl; <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-using-使用命名空间"><a href="#使用-using-使用命名空间" class="headerlink" title="使用 using 使用命名空间"></a>使用 using 使用命名空间</h3><p>我们可以使用 <code>using</code> 关键字使用命名空间，使得命名空间中的内容在此作用域内可见，从而不需要通过作用域运算符访问命名空间中的内容。</p><ul><li>使用整个命名空间</li></ul><p><code>using namespace 命名空间名;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> aaa &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用了 std 和 aaa 两个命名空间 */</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> aaa;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 下面两条语句的效果相同 */</span></span><br><span class="line">  std::cout &lt;&lt; aaa::a &lt;&lt; aaa::b &lt;&lt; std::endl;</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用命名空间中的部分内容</li></ul><p><code>using 命名空间名::标识符;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> aaa &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用了 std 中的 cout 与 endl */</span></span><br><span class="line"><span class="keyword">using</span> std::cout, std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用了 aaa 中的 a */</span></span><br><span class="line"><span class="keyword">using</span> aaa:a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; aaa::a &lt;&lt; aaa::b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 并没有使用 aaa 中的 b，所以还需要使用作用域运算符访问 */</span></span><br><span class="line">  cout &lt;&lt; a &lt;&lt; aaa::b &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在定义和使用命名空间时的注意点"><a href="#在定义和使用命名空间时的注意点" class="headerlink" title="在定义和使用命名空间时的注意点"></a>在定义和使用命名空间时的注意点</h2><ul><li><p>命名空间的大括号后面不需要分号结束。</p></li><li><p>命名空间内的缩进可以根据个人喜好或公司代码规范来调整。</p></li><li><p>可以在一个文件内出现多个命名空间，也可以在多个文件内出现同一个名字的命名空间，但同名命名空间内绝对不能出现重名的标识符。</p><ul><li>一个文件出现多个命名空间 ✅</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> aaa &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bbb &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; aaa:a &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">  std::cout &lt;&lt; bbb:a &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多个文件中出现同一个名字的命名空间 ✅</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file_a.cpp */</span></span><br><span class="line"><span class="keyword">namespace</span> aaa &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file_b.cpp */</span></span><br><span class="line"><span class="keyword">namespace</span> aaa &#123;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样做并不好，因为这样虽然编译能通过，但是在 <code>file_a.cpp</code> 中并不能够访问到 <code>file_b.cpp</code> 中的那部分。</p><p>所以正确的做法是将它们放在不同的头文件中来方便我们引入，如果你需要在命名空间中存放的内容并不多，且内容同属一个模块，那么直接放在一个文件中即可。</p></blockquote><ul><li>多个文件中出现同一个名字的命名空间，并出现了重名的标识符 ❌</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file_a.cpp */</span></span><br><span class="line"><span class="comment">/* 错误示范 */</span></span><br><span class="line"><span class="keyword">namespace</span> aaa &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file_b.cpp */</span></span><br><span class="line"><span class="comment">/* 错误示范 */</span></span><br><span class="line"><span class="keyword">namespace</span> aaa &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做就等同于在一个作用域内声明&#x2F;定义了同名标识符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误示范 */</span></span><br><span class="line"><span class="keyword">namespace</span> aaa &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>using</code> 命名空间时，也请保证在一个作用域内不会出现可见的多个同名标识符，否则编译不通过，出现链接错误。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> C++ </tag>
            
            <tag> namespace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的引用（入门）</title>
      <link href="/CPP/CPP%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/58b51aa954b6/"/>
      <url>/CPP/CPP%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/58b51aa954b6/</url>
      
        <content type="html"><![CDATA[<h2 id="C-中的引用是什么"><a href="#C-中的引用是什么" class="headerlink" title="C++中的引用是什么"></a>C++中的引用是什么</h2><p>主要是用来解决指针太麻烦的问题而设计的一种新的语法格式，本质上是指针常量。</p><h3 id="相较于指针的优缺点"><a href="#相较于指针的优缺点" class="headerlink" title="相较于指针的优缺点"></a>相较于指针的优缺点</h3><ul><li>优点：避免指针的麻烦写法</li><li>缺点：无法改变引用的指向、必须声明时初始化</li></ul><h2 id="使用引用"><a href="#使用引用" class="headerlink" title="使用引用"></a>使用引用</h2><h3 id="引用的语法格式"><a href="#引用的语法格式" class="headerlink" title="引用的语法格式"></a>引用的语法格式</h3><p>数据类型 &amp;引用名 &#x3D; 原变量;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;ra = a; <span class="comment">// 相当于 const int *ra = a;</span></span><br></pre></td></tr></table></figure><h3 id="引用的特点"><a href="#引用的特点" class="headerlink" title="引用的特点"></a>引用的特点</h3><ul><li>必须在声明的同时初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;ra;      <span class="comment">// ❌ declaration of reference variable &#x27;ra&#x27; requires an initializer</span></span><br><span class="line"><span class="type">int</span> &amp;ra = a;  <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure><ul><li>必须保证引用类型和被引用变量的类型一致</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">long</span> &amp;lra = a; <span class="comment">// ❌ non-const lvalue reference to type &#x27;long&#x27; cannot bind to a value of unrelated type &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>不能够改变指向（不能够换绑）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;ra = a;</span><br><span class="line">ra = b; <span class="comment">// 实际上等同于 a = 4, 并不是改变指向</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ra: &quot;</span> &lt;&lt; ra &lt;&lt; std::endl; <span class="comment">// 4</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;   <span class="comment">// 4</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl;   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h2 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h2><h3 id="例子引入：交换两变量的值"><a href="#例子引入：交换两变量的值" class="headerlink" title="例子引入：交换两变量的值"></a>例子引入：交换两变量的值</h3><ul><li>传统指针交换两个变量的值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapByPointer</span><span class="params">(<span class="type">int</span> *pa, <span class="type">int</span> *pb)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要频繁解引用，差评❌</span></span><br><span class="line">  <span class="type">int</span> t = *pa;</span><br><span class="line">  *pa = *pb;</span><br><span class="line">  *pb = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SwapByPointer</span>(&amp;a, &amp;b); <span class="comment">// 传入需要加取地址符，差评❌</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引用作为函数参数交换两个变量的值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapByReference</span><span class="params">(<span class="type">int</span> &amp;ra, <span class="type">int</span> &amp;rb)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 可以直接当成普通变量使用，好评✅</span></span><br><span class="line">  <span class="type">int</span> t = ra;</span><br><span class="line">  ra = rb;</span><br><span class="line">  rb = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SwapByReference</span>(a, b); <span class="comment">// 直接当成普通的值传入，好评✅</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子引入：对传入字面量或常量的处理"><a href="#例子引入：对传入字面量或常量的处理" class="headerlink" title="例子引入：对传入字面量或常量的处理"></a>例子引入：对传入字面量或常量的处理</h3><ul><li>形参为普通引用时传入字面量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintValue1</span><span class="params">(<span class="type">int</span> &amp;ra)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ra: &quot;</span> &lt;&lt; ra &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">PrintValue1</span>(<span class="number">10</span>); <span class="comment">// ❌ no matching function for call to &#x27;PrintValue2&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>形参为常引用时传入字面量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintValue2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;cra)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;cra: &quot;</span> &lt;&lt; cra &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">PrintValue2</span>(<span class="number">10</span>); <span class="comment">// ✅</span></span><br><span class="line">  <span class="built_in">PrintValue2</span>(a);  <span class="comment">// ✅</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原理：虽然说参数为常引用时，它本质还是指针，依然需要接收地址，但是 C++ 对策略是：当传入参数时, 如果传入的是一个右值, 那么将会有一个临时变量存放这个值, 并且引用将会绑定这个临时变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当字面量 20 传入时, 相当于</span></span><br><span class="line"><span class="type">int</span> temp = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;cra = temp;</span><br></pre></td></tr></table></figure></blockquote><h2 id="对指针的引用"><a href="#对指针的引用" class="headerlink" title="对指针的引用"></a>对指针的引用</h2><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><p>数据类型 *&amp;引用名 &#x3D; 原指针;</p><h3 id="例子引入：在函数内改变指针的指向"><a href="#例子引入：在函数内改变指针的指向" class="headerlink" title="例子引入：在函数内改变指针的指向"></a>例子引入：在函数内改变指针的指向</h3><ul><li>传统二级指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Allocate1</span><span class="params">(<span class="type">int</span> **pp)</span> </span>&#123;</span><br><span class="line">  *pp = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">Allocate1</span>(&amp;p1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对一级指针的引用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Allocate2</span><span class="params">(<span class="type">int</span> *&amp;rp)</span> </span>&#123;</span><br><span class="line">  rp = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *p2 = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">Allocate1</span>(p2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用作为函数的返回值"><a href="#引用作为函数的返回值" class="headerlink" title="引用作为函数的返回值"></a>引用作为函数的返回值</h2><h3 id="返回一个有效引用的前提"><a href="#返回一个有效引用的前提" class="headerlink" title="返回一个有效引用的前提"></a>返回一个有效引用的前提</h3><p>如果要保证返回一个有效的引用，那么返回变量的生命周期必须要长于用于接收的引用，否则就是野指针。</p><h3 id="返回引用的一些例子"><a href="#返回引用的一些例子" class="headerlink" title="返回引用的一些例子"></a>返回引用的一些例子</h3><ul><li>局部变量作为引用返回</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 的生命周期在函数运行结束之前, 无法被真正接收</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">ReturnLocalVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> &amp;ra = <span class="built_in">ReturnLocalVar</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;ra: &quot;</span> &lt;&lt; ra &lt;&lt; std::endl; <span class="comment">// 野指针, 乱值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态局部变量作为引用返回</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论是全局还是局部的静态变量，生命周期都在程序结束之前, 可以被接收</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">ReturnStaticVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> &amp;ra = <span class="built_in">ReturnLocalVar</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;ra: &quot;</span> &lt;&lt; ra &lt;&lt; std::endl; <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引用参数作为返回值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把传进来的引用 ra 处理完再返回去</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">ReturnRefParam</span><span class="params">(<span class="type">int</span> &amp;ra, <span class="type">const</span> <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">  ra = value;</span><br><span class="line">  <span class="keyword">return</span> ra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> &amp;rc = <span class="built_in">ReturnRefParam</span>(c, <span class="number">20</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;rc: &quot;</span> &lt;&lt; rc &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回的引用可作为左值, 在这里相当于 c = 40</span></span><br><span class="line">  <span class="comment">// c 原本的值是 20, 调用函数时, 在函数内部被改为了 30, 作为引用被返回后又被赋值为 40</span></span><br><span class="line">  <span class="built_in">ReturnRefParam</span>(c, <span class="number">30</span>) = <span class="number">40</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;rc: &quot;</span> &lt;&lt; rc &lt;&lt; endl; <span class="comment">// 40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>引用的本质就是指针常量，但是对写法进行了包装，既有指针的功能，又简便了写法</li><li>引用必须在声明时初始化，且不能换绑或进行类型强转</li><li>可以对一级指针进行引用，以避免二级指针的写法，但注意声明语句的 <code>*</code> 一定是在 <code>&amp;</code> 前面</li><li>注意作为引用返回的变量的生命周期，避免野指针</li></ul>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> C++ </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SDKMAN进行jdk的版本管理</title>
      <link href="/JavaSE/%E4%BD%BF%E7%94%A8SDKMAN%E8%BF%9B%E8%A1%8Cjdk%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/6442600ff246/"/>
      <url>/JavaSE/%E4%BD%BF%E7%94%A8SDKMAN%E8%BF%9B%E8%A1%8Cjdk%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/6442600ff246/</url>
      
        <content type="html"><![CDATA[<h2 id="诶，还没写呢～"><a href="#诶，还没写呢～" class="headerlink" title="诶，还没写呢～"></a>诶，还没写呢～</h2>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jdk </tag>
            
            <tag> SDKMAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的注解</title>
      <link href="/JavaSE/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/50cef68448ad/"/>
      <url>/JavaSE/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/50cef68448ad/</url>
      
        <content type="html"><![CDATA[<blockquote><p>部分资料来源：<a href="http://c.biancheng.net./">http://c.biancheng.net。</a></p></blockquote><h2 id="一、注解的概念"><a href="#一、注解的概念" class="headerlink" title="一、注解的概念"></a>一、注解的概念</h2><p>从 jdk 1.5 之后可以在源代码中嵌入一些补充信息，这种补充信息称为注解（Annotation）。注解并不能改变程序的运行结果，也不会影响程序运行的性能。有些注解可以在编译时给用户提示或警告，有的注解可以在运行时读写字节码文件信息。</p><h2 id="二、注解的作用"><a href="#二、注解的作用" class="headerlink" title="二、注解的作用"></a>二、注解的作用</h2><ol><li>生成帮助文档。这是最常见的，也是 Java 最早提供的注解。常用的有 <code>@see</code>、<code>@param</code> 和 <code>@return</code> 等；</li><li>跟踪代码依赖性，实现替代配置文件功能。比较常见的是 <code>Spring 2.5</code> 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量；</li><li>在编译时进行格式检查。如把 <code>@Override</code> 注解放在方法前，如果这个方法并不是重写了父类方法，则编译时就能检查出。</li></ol><h2 id="三、常用的注解"><a href="#三、常用的注解" class="headerlink" title="三、常用的注解"></a>三、常用的注解</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在 jdk 1.8 中提供了 11 种内部注解，其中有 5 个基本注解、6 个元注解。</p><p>基本注解包括：@Override、@Deprecated、@SuppressWarnings、@SafeVarargs 和 @FunctionalInterface。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="Override-注解"><a href="#Override-注解" class="headerlink" title="@Override 注解"></a>@Override 注解</h4><p>作用目标：成员方法</p><p>作用：对方法进行对父类方法重写的检查，保证重写的一定是父类原有的方法。（重写就是子类重新定义覆盖父类原有的方法，方法签名保持一致，但其内容被改变。）</p><p>例：如下代码中是一个 <code>Person</code> 类中对 <code>toString</code> 方法的覆盖重写（<code>toString</code> 方法是 <code>Object</code> 类中的方法），如果方法签名与父类不一致，则编译会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Person.java */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">    <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Deprecated-注解"><a href="#Deprecated-注解" class="headerlink" title="@Deprecated 注解"></a>@Deprecated 注解</h4><p>作用目标：构造方法、成员变量、局部变量、方法、参数、类等</p><p>作用：用于将某个元素标记为过时的元素，使用过时的元素在编译时会给出警告。（在现代 IDE 中，如 <code>IntelliJ IDEA</code>，使用过时的元素会有删除线的效果）</p><h4 id="SuppressWarnings-注解"><a href="#SuppressWarnings-注解" class="headerlink" title="@SuppressWarnings 注解"></a>@SuppressWarnings 注解</h4><p>作用目标：构造方法、成员变量、局部变量、方法、参数、类等</p><p>作用：消除警告</p><table><thead><tr><th>关键字</th><th>用途</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td></tr><tr><td>fallthrough</td><td>抑制在 switch 中缺失 breaks 的警告</td></tr><tr><td>finally</td><td>抑制 finally 模块没有返回的警告</td></tr><tr><td>hiding</td><td>抑制相对于隐藏变量的局部变量的警告</td></tr><tr><td>incomplete-switch</td><td>忽略不完整的 switch 语句</td></tr><tr><td>nls</td><td>忽略非 nls 格式的字符</td></tr><tr><td>null</td><td>忽略对 null 的操作</td></tr><tr><td>rawtypes</td><td>使用 generics 时忽略没有指定相应的类型</td></tr><tr><td>restriction</td><td>抑制禁止使用劝阻或禁止引用的警告</td></tr><tr><td>serial</td><td>忽略在 serializable 类中没有声明 serialVersionUID 变量</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td></tr></tbody></table><p>例：消除使用过期方法的警告</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Student.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将成员方法 study() 标记为已弃用方法</span></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main.java */</span></span><br><span class="line"><span class="comment">// 将 @SuppressWarnings 注解作用在 main() 方法，使得在 main() 方法中使用已弃用方法不会得到警告</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">  student.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SafeVarargs-注解"><a href="#SafeVarargs-注解" class="headerlink" title="@SafeVarargs 注解"></a>@SafeVarargs 注解</h4><p>作用目标：构造方法、方法（不适用于非 static 或 非 final 方法，请改用 <code>@SuppressWarnings</code> 注解）</p><p>作用：消除来自形参化 vararg 类型的可能的堆污染警告</p><blockquote><p>堆污染是一个技术术语。它指的是引用的类型不是它们指向的对象的父类型。所以可能会引发异常</p></blockquote><p>例：消除可能存在堆污染的警告</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T... args)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (T arg : args) &#123;</span><br><span class="line">    <span class="comment">// 用到了一点点反射，作用是拿到 arg 的类对象，然后拿到类名。</span></span><br><span class="line">    System.out.println(arg.getClass().getName() + <span class="string">&quot;: &quot;</span> + arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FunctionalInterface-注解"><a href="#FunctionalInterface-注解" class="headerlink" title="@FunctionalInterface 注解"></a>@FunctionalInterface 注解</h4><p>作用目标：接口</p><p>作用：检查并保证该接口为函数式接口（接口中仅包含一个抽象方法，如果没有或有多个抽象方法，编译器会报错）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IFunctionalTest.java */</span></span><br><span class="line"><span class="comment">// 定义一个没啥用（仅用来测试）的函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFunctionalTest</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main.java */</span></span><br><span class="line"><span class="comment">// 用 lambda 表达式来实现接口中的抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">IFunctionalTest</span> <span class="variable">test</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">  test.test(); <span class="comment">// &quot;test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、元注解与自定义注解"><a href="#四、元注解与自定义注解" class="headerlink" title="四、元注解与自定义注解"></a>四、元注解与自定义注解</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>在 jdk 1.8 中提供了6 个元注解（元注解就是注解的注解，定义一个新注解需要用到元注解）</p><p>包括：@Documented、@Target、@Retention、@Inherited、@Repeatable 和 @Native。其中 @Repeatable 和 @Native 注解是 jdk 1.8 新增。</p><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义 */</span></span><br><span class="line">访问修饰 <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">访问修饰 类型名 成员变量名() <span class="keyword">default</span> 默认值;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">@注解名(成员变量名<span class="number">1</span> = 值<span class="number">1</span>, 成员变量名<span class="number">2</span> = 值<span class="number">2.</span>..)</span><br><span class="line">各种元素;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><strong>访问修饰符只能是 public 和 (default)(表示不写、默认，并非是关键字 default)，无论是注解还是注解的成员变量。</strong></li><li><strong>成员变量名后要加一对小括号。</strong></li><li><strong>注解的成员变量可以有默认值，通过 <code>default</code>关键字指定默认值。</strong></li><li><strong>如果注解只有一个成员变量并且名字为 <code>value</code>，那么则可以直接写成 @注解名(值) 的形式。</strong></li></ol><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>在默认情况下，<code>Java doc</code> 不会提取注解信息，但是如果声明注解时使用了 <code>@Documented</code> 注解，那么该注解就能够被 <code>Java doc</code> 提取到。</p><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p><code>@Target</code> 注解用来指定注解的作用目标，也就是该注解能够用在哪些目标下。目标有以下几种：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>CONSTRUCTOR</td><td>用于构造方法</td></tr><tr><td>FIELD</td><td>用于成员变量（包括枚举常量）</td></tr><tr><td>LOCAL_VARIABLE</td><td>用于局部变量</td></tr><tr><td>METHOD</td><td>用于方法</td></tr><tr><td>PACKAGE</td><td>用于包</td></tr><tr><td>PARAMETER</td><td>用于类型参数（JDK 1.8新增）</td></tr><tr><td>TYPE</td><td>用于类、接口（包括注解类型）或 enum 声明</td></tr></tbody></table><p>上述值是枚举类型 <code>ElementType</code> 的值，存在于 <code>java.lang.annotation</code> 包下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MyAnnotation.java */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="meta">@MyAnnotation(&quot;number&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码是 <code>@Target</code> 注解的使用示例，<code>@MyAnnotation</code> 注解适用于成员变量，如果放在其他元素上会导致编译不通过。</p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p><code>@Retention</code> 注解用于指定注解的生命周期，生命周期有以下 3 种：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>SOURCE</td><td>在资源文件中有效，注解将被编译器丢弃</td></tr><tr><td>CLASS</td><td>会被编译器记录在 .class 文件中，但在运行时不会被 VM 保留</td></tr><tr><td>RUNTIME</td><td>在运行时有效，运行时会被 VM 保留并可能被反射获取到</td></tr></tbody></table><p>上述值是枚举类型 <code>RetentionPolicy</code> 的值，同样存在于 <code>java.lang.annotation</code> 包下。</p><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p><code>@Repeatable</code> 可以使同一个注解在同一个目标上重复使用，但是需要一个容器注解配合。</p><p>在没有 <code>@Repeatable</code> 注解时在同一个目标上重复使用同一个注解：要套壳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MyAnnotation.java */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MyAnnotations.java */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line">MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="meta">@MyAnnotations(&#123;</span></span><br><span class="line"><span class="meta">@MyAnnotation(&quot;repeat&quot;),</span></span><br><span class="line"><span class="meta">@MyAnnotation(&quot;repeat&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>@Repeatable</code> 注解：可在同一目标直接上重复使用注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MyAnnotation.java */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="meta">@MyAnnotation(&quot;repeat&quot;)</span></span><br><span class="line">  <span class="meta">@MyAnnotation(&quot;repeat&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：无论有没有 <code>@Repeatable</code> 注解都需要一个容器注解用于存放注解，使用了 <code>@Repeatable</code> 注解只是在重复使用同一注解时省略了套壳而已。</strong></p><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>正常情况下，子类继承父类时，不会将作用在父类上的注解也继承过来。</p><p>而 <code>@Inherited</code> 注解的作用就是让子类继承父类的时候将注解也一并继承过来。</p><p>请看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MyAnnotation.java */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Person.java */</span></span><br><span class="line"><span class="meta">@MyAnnotation(&quot;ttt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Student.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test.java */</span></span><br><span class="line">Annotation[] annotations = Student.class.getAnnotations();</span><br><span class="line"><span class="keyword">for</span> (Annotation a : annotations) &#123;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行没有打印任何结果</span></span><br></pre></td></tr></table></figure><p>以上代码中定义了一个 <code>@MyAnnotation</code> 注解，<code>Person</code> 类和 <code>Student</code> 类，注解作用在<code>Person</code> 类上 <code>Student</code> 类继承自 <code>Person</code> 类。我们在测试代码中浅浅的使用了 Java 的反射特性来获取作用在类上的注解，但是没有任何结果，说明作用在其上的注解并没有被继承过来。</p><p>我们为 <code>@MyAnnotation</code> 注解加上 <code>@Inherited</code> 试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MyAnnotation.java */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test.java */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 运行结果：@com.jm.MyAnnotation(value=&quot;ttt&quot;)</span></span><br></pre></td></tr></table></figure><p>可以看到有结果了，打印出来了完整注解名和其中成员变量的值，说明该注解有被子类继承过来。</p><blockquote><p>反射在下一篇章，也有些书籍或教程上会先讲反射再讲注解。</p></blockquote><h4 id="Native"><a href="#Native" class="headerlink" title="@Native"></a>@Native</h4><p><code>@Native</code> 注解只适用于字段。它指示带注释的字段是可以从本机代码引用的常量。例：它在 <code>Integer</code> 类中是如何使用的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line">  <span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_VALUE</span> <span class="operator">=</span> <span class="number">0x80000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解还可以作为工具生成一些辅助头文件的提示。</p><blockquote><p>@Native 注解这段解释搬运自</p><p><a href="https://www.baeldung.com/java-default-annotations">https://www.baeldung.com/java-default-annotations</a></p><p>由于本人能力有限，实在不知道该注解的作用以及如何使用，所以就直接把该网站上对其的解释搬运过来了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS使用ssh密钥连接远程服务器</title>
      <link href="/%E5%85%B6%E4%BB%96/MacOS%E4%BD%BF%E7%94%A8ssh%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/0981664a56f1/"/>
      <url>/%E5%85%B6%E4%BB%96/MacOS%E4%BD%BF%E7%94%A8ssh%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/0981664a56f1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、在本地生成密钥"><a href="#一、在本地生成密钥" class="headerlink" title="一、在本地生成密钥"></a>一、在本地生成密钥</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><blockquote><p>一路回车就行了，ssh-keygen 在 MacOS 下会把密钥生成在 <code>/User/用户名/.ssh</code> 下</p></blockquote><h2 id="二、将公钥拷贝到服务器上"><a href="#二、将公钥拷贝到服务器上" class="headerlink" title="二、将公钥拷贝到服务器上"></a>二、将公钥拷贝到服务器上</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i /User/用户名/.ssh/id_rsa.pub root@ip</span><br></pre></td></tr></table></figure><blockquote><p>执行以上命令会要求验证，输入服务器密码就行了</p></blockquote><h2 id="三、连接"><a href="#三、连接" class="headerlink" title="三、连接"></a>三、连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@ip</span><br></pre></td></tr></table></figure><blockquote><p>可以愉快的使用了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言轻量级单元测试</title>
      <link href="/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/d553fbcb363f/"/>
      <url>/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/d553fbcb363f/</url>
      
        <content type="html"><![CDATA[<h2 id="minunit"><a href="#minunit" class="headerlink" title="minunit"></a>minunit</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>项目地址：<a href="https://github.com/siu/minunit">https://github.com/siu/minunit</a></p><p>开源协议：MIT License</p><p>一个非常轻便的、便于使用的 C 语言单元测试框架。它没有任何依赖，所有功能都以宏函数的形式放在头文件中，开箱即用。该项目的 README 中是这样描述的：</p><blockquote><p>Minunit 是一个最小的 C&#x2F;C++ 单元测试框架，独立于单个头文件中。</p><p>它提供了一种定义和配置测试套件以及一些方便的断言类型的方法。它报告运行的测试数量、断言数量和经过的时间的摘要。</p><p>请注意，该项目基于： <a href="http://www.jera.com/techinfo/jtns/jtn002.html">http://www.jera.com/techinfo/jtns/jtn002.html</a></p></blockquote><p>该项目基于 <code>John Brewer</code> 的 “C 的最小单元测试框架” MinUnit。它只有三行，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file: minunit.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mu_assert(message, test) do &#123; <span class="keyword">if</span> (!(test)) return message; &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mu_run_test(test) do &#123; char *message = test(); tests_run++; <span class="keyword">if</span> (message) return message; &#125; while (0)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> tests_run;</span><br></pre></td></tr></table></figure><p>这是一个极其简单的单元测试框架（或许不应该叫它框架），它只拥有简单的断言、运行测试用例、测试用例技术的功能。很显然，它的功能并不完善，在更大的项目中不便于使用，所以就有了本文中介绍的，更加完善，同时也保持它的轻便的 MinUnit。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="引入-MinUnit"><a href="#引入-MinUnit" class="headerlink" title="引入 MinUnit"></a>引入 MinUnit</h4><p>直接包含头文件即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minunit.h&quot;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; <span class="comment">// ... &#125;</span></span><br></pre></td></tr></table></figure><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p><strong>mu_check(condition)</strong>: 检测传入的布尔表达式是否为真，如果不为真则打印错误信息。</p><p><strong>mu_fail(message)</strong>: 手动出错，打印信息。（计入断言数量）</p><p><strong>mu_assert(test, message)</strong>: 在 <code>mu_check()</code> 的基础上加上失败打印自定义信息。</p><p><strong>mu_assert_int_eq(expected, result)</strong>: 检测返回值是否与期望值相等（整型）。</p><p><strong>mu_assert_string_eq(expected, result)</strong>: 检测返回值是否与期望值相等（字符串）。</p><p><strong>mu_assert_double_eq(expected, result)</strong>: 检测返回值是否与期望值近似（浮点型），精度阈值通过在头文件中定义的宏 <code>MINUNIT_EPSILON</code> 来控制。</p><blockquote><p>判断两个浮点数是否近似：两数之差的绝对值与阈值 <strong>EPSILON</strong> 做比较，如果它小于 <strong>EPSILON</strong> 则两数近似。</p></blockquote><h4 id="测试用例和测试组合"><a href="#测试用例和测试组合" class="headerlink" title="测试用例和测试组合"></a>测试用例和测试组合</h4><p>我们可以用 <code>MU_TEST()</code> 定义一个测试用例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MU_TEST(test_case1) &#123; <span class="comment">// ... &#125;</span></span><br></pre></td></tr></table></figure><p>实际上，上面的代码会被展开为这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">test_case1</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>MU_RUN_TEST()</code> 运行测试用例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minunit.h&quot;</span></span></span><br><span class="line">MU_TEST(test_case1) &#123; mu_check(<span class="number">5</span> == <span class="number">7</span>); &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  MU_RUN_TEST(test_case1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试组合可以用 <code>MU_TEST_SUITE()</code> 定义，一个测试组合可以将多个测试用例组合起来（其实就是一个函数里面调用了一堆函数）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MU_TEST(test_case1) &#123; mu_check(<span class="number">5</span> == <span class="number">7</span>); &#125;</span><br><span class="line">MU_TEST(test_case2) &#123; mu_check(<span class="number">5</span> != <span class="number">7</span>); &#125;</span><br><span class="line"></span><br><span class="line">MU_TEST_SUITE(test_suite1) &#123;</span><br><span class="line">  MU_RUN_TEST(test_case1);</span><br><span class="line">  MU_RUN_TEST(test_case2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>MU_RUN_SUITE()</code> 运行测试组合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minunit.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  MU_RUN_SUITE(test_suite1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="装载与卸载函数"><a href="#装载与卸载函数" class="headerlink" title="装载与卸载函数"></a>装载与卸载函数</h4><p>我们可以通过在测试组合中使用 <code>MU_SUITE_CONFIGURE()</code> 来绑定装载函数与卸载函数。装载函数和卸载函数会在运行每一个测试用例之前和之后运行，用于运行测试用例的准备工作和善后工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minunit.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_setup</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;test_setup\n&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_teardown</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;test_teardown\n&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">MU_TEST(test_case1) &#123; mu_check(<span class="number">5</span> != <span class="number">7</span>); &#125;</span><br><span class="line">MU_TEST(test_case2) &#123; mu_check(<span class="number">6</span> == <span class="number">7</span>); &#125;</span><br><span class="line"></span><br><span class="line">MU_TEST_SUITE(test_suite1) &#123;</span><br><span class="line">  MU_SUITE_CONFIGURE(&amp;test_setup, &amp;test_teardown);</span><br><span class="line">  MU_RUN_TEST(test_case1);</span><br><span class="line">  MU_RUN_TEST(test_case2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  MU_RUN_SUITE(test_suite1);</span><br><span class="line">  MU_REPORT();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在一个测试组合中运行了两个测试用例，并且绑定了装载函数和卸载函数。这两个函数会在运行每个测试用例前后运行。</p><h4 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h4><p>通过 <code>MU_REPORT()</code> 打印当前为止的测试结果报告，他将打印测试用例的个数、断言的个数和失败的个数，并计算测试完成的真实时间与处理器时间。以上代码运行结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test_setup</span><br><span class="line">.test_teardown</span><br><span class="line">test_setup</span><br><span class="line">F</span><br><span class="line">test_case2 failed:</span><br><span class="line">/Users/jm/CLionProjects/data_structure/test/llist/llist_test.c:144: 6 == 7</span><br><span class="line">test_teardown</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2 tests, 2 assertions, 1 failures</span><br><span class="line"></span><br><span class="line">Finished in 0.00004292 seconds (real) 0.00000800 seconds (proc)</span><br></pre></td></tr></table></figure><h3 id="END，可以愉快使用了！"><a href="#END，可以愉快使用了！" class="headerlink" title="END，可以愉快使用了！"></a>END，可以愉快使用了！</h3>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/uncategorized/hello-world/31284834e87b/"/>
      <url>/uncategorized/hello-world/31284834e87b/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
