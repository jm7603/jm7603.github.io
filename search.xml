<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++中的引用（入门）</title>
      <link href="/CPP/CPP%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/58b51aa954b6/"/>
      <url>/CPP/CPP%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/58b51aa954b6/</url>
      
        <content type="html"><![CDATA[<h2 id="C-中的引用是什么"><a href="#C-中的引用是什么" class="headerlink" title="C++中的引用是什么"></a>C++中的引用是什么</h2><p>主要是用来解决指针太麻烦的问题而设计的一种新的语法格式，本质上是指针常量。</p><h3 id="相较于指针的优缺点"><a href="#相较于指针的优缺点" class="headerlink" title="相较于指针的优缺点"></a>相较于指针的优缺点</h3><ul><li>优点：避免指针的麻烦写法</li><li>缺点：无法改变引用的指向、必须声明时初始化</li></ul><h2 id="使用引用"><a href="#使用引用" class="headerlink" title="使用引用"></a>使用引用</h2><h3 id="引用的语法格式"><a href="#引用的语法格式" class="headerlink" title="引用的语法格式"></a>引用的语法格式</h3><p>数据类型 &amp;引用名 &#x3D; 原变量;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;ra = a; <span class="comment">// 相当于 const int *ra = a;</span></span><br></pre></td></tr></table></figure><h3 id="引用的特点"><a href="#引用的特点" class="headerlink" title="引用的特点"></a>引用的特点</h3><ul><li>必须在声明的同时初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;ra;      <span class="comment">// ❌ declaration of reference variable &#x27;ra&#x27; requires an initializer</span></span><br><span class="line"><span class="type">int</span> &amp;ra = a;  <span class="comment">// ✅</span></span><br></pre></td></tr></table></figure><ul><li>必须保证引用类型和被引用变量的类型一致</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">long</span> &amp;lra = a; <span class="comment">// ❌ non-const lvalue reference to type &#x27;long&#x27; cannot bind to a value of unrelated type &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>不能够改变指向（不能够换绑）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;ra = a;</span><br><span class="line">ra = b; <span class="comment">// 实际上等同于 a = 4, 并不是改变指向</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ra: &quot;</span> &lt;&lt; ra &lt;&lt; std::endl; <span class="comment">// 4</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;<span class="comment">// 4</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h2 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h2><h3 id="例子引入：交换两变量的值"><a href="#例子引入：交换两变量的值" class="headerlink" title="例子引入：交换两变量的值"></a>例子引入：交换两变量的值</h3><ul><li>传统指针交换两个变量的值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapByPointer</span><span class="params">(<span class="type">int</span> *pa, <span class="type">int</span> *pb)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要频繁解引用，差评❌</span></span><br><span class="line">  <span class="type">int</span> t = *pa;</span><br><span class="line">  *pa = *pb;</span><br><span class="line">  *pb = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SwapByPointer</span>(&amp;a, &amp;b); <span class="comment">// 传入需要加取地址符，差评❌</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引用作为函数参数交换两个变量的值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapByReference</span><span class="params">(<span class="type">int</span> &amp;ra, <span class="type">int</span> &amp;rb)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 可以直接当成普通变量使用，好评✅</span></span><br><span class="line">  <span class="type">int</span> t = ra;</span><br><span class="line">  ra = rb;</span><br><span class="line">  rb = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SwapByReference</span>(a, b); <span class="comment">// 直接当成普通的值传入，好评✅</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子引入：对传入字面量或常量的处理"><a href="#例子引入：对传入字面量或常量的处理" class="headerlink" title="例子引入：对传入字面量或常量的处理"></a>例子引入：对传入字面量或常量的处理</h3><ul><li>形参为普通引用时传入字面量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintValue1</span><span class="params">(<span class="type">int</span> &amp;ra)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ra: &quot;</span> &lt;&lt; ra &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">PrintValue1</span>(<span class="number">10</span>); <span class="comment">// ❌ no matching function for call to &#x27;PrintValue2&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>形参为常引用时传入字面量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintValue2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;cra)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;cra: &quot;</span> &lt;&lt; cra &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">PrintValue2</span>(<span class="number">10</span>); <span class="comment">// ✅</span></span><br><span class="line">  <span class="built_in">PrintValue2</span>(a);  <span class="comment">// ✅</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原理：虽然说参数为常引用时，它本质还是指针，依然需要接收地址，但是 C++ 对策略是：当传入参数时, 如果传入的是一个右值, 那么将会有一个临时变量存放这个值, 并且引用将会绑定这个临时变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当字面量 20 传入时, 相当于</span></span><br><span class="line"><span class="type">int</span> temp = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;cra = temp;</span><br></pre></td></tr></table></figure></blockquote><h2 id="对指针的引用"><a href="#对指针的引用" class="headerlink" title="对指针的引用"></a>对指针的引用</h2><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><p>数据类型 *&amp;引用名 &#x3D; 原指针;</p><h3 id="例子引入：在函数内改变指针的指向"><a href="#例子引入：在函数内改变指针的指向" class="headerlink" title="例子引入：在函数内改变指针的指向"></a>例子引入：在函数内改变指针的指向</h3><ul><li>传统二级指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Allocate1</span><span class="params">(<span class="type">int</span> **pp)</span> </span>&#123;</span><br><span class="line">  *pp = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">Allocate1</span>(&amp;p1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对一级指针的引用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Allocate2</span><span class="params">(<span class="type">int</span> *&amp;rp)</span> </span>&#123;</span><br><span class="line">  rp = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *p2 = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">Allocate1</span>(p2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用作为函数的返回值"><a href="#引用作为函数的返回值" class="headerlink" title="引用作为函数的返回值"></a>引用作为函数的返回值</h2><h3 id="返回一个有效引用的前提"><a href="#返回一个有效引用的前提" class="headerlink" title="返回一个有效引用的前提"></a>返回一个有效引用的前提</h3><p>如果要保证返回一个有效的引用，那么返回变量的生命周期必须要长于用于接收的引用，否则就是野指针。</p><h3 id="返回引用的一些例子"><a href="#返回引用的一些例子" class="headerlink" title="返回引用的一些例子"></a>返回引用的一些例子</h3><ul><li>局部变量作为引用返回</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 的生命周期在函数运行结束之前, 无法被真正接收</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">ReturnLocalVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> &amp;ra = <span class="built_in">ReturnLocalVar</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;ra: &quot;</span> &lt;&lt; ra &lt;&lt; std::endl; <span class="comment">// 野指针, 乱值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态局部变量作为引用返回</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论是全局还是局部的静态变量，生命周期都在程序结束之前, 可以被接收</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">ReturnStaticVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> &amp;ra = <span class="built_in">ReturnLocalVar</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;ra: &quot;</span> &lt;&lt; ra &lt;&lt; std::endl; <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引用参数作为返回值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把传进来的引用 ra 处理完再返回去</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">ReturnRefParam</span><span class="params">(<span class="type">int</span> &amp;ra, <span class="type">const</span> <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">  ra = value;</span><br><span class="line">  <span class="keyword">return</span> ra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> &amp;rc = <span class="built_in">ReturnRefParam</span>(c, <span class="number">20</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;rc: &quot;</span> &lt;&lt; rc &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回的引用可作为左值, 在这里相当于 c = 40</span></span><br><span class="line">  <span class="comment">// c 原本的值是 20, 调用函数时, 在函数内部被改为了 30, 作为引用被返回后又被赋值为 40</span></span><br><span class="line">  <span class="built_in">ReturnRefParam</span>(c, <span class="number">30</span>) = <span class="number">40</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;rc: &quot;</span> &lt;&lt; rc &lt;&lt; endl; <span class="comment">// 40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>引用的本质就是指针常量，但是对写法进行了包装，既有指针的功能，又简便了写法</li><li>引用必须在声明时初始化，且不能换绑或进行类型强转</li><li>可以对一级指针进行引用，以避免二级指针的写法，但注意声明语句的 <code>*</code> 一定是在 <code>&amp;</code> 前面</li><li>注意作为引用返回的变量的生命周期，避免野指针</li></ul>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> C++ </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SDKMAN进行jdk的版本管理</title>
      <link href="/JavaSE/%E4%BD%BF%E7%94%A8SDKMAN%E8%BF%9B%E8%A1%8Cjdk%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/6442600ff246/"/>
      <url>/JavaSE/%E4%BD%BF%E7%94%A8SDKMAN%E8%BF%9B%E8%A1%8Cjdk%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/6442600ff246/</url>
      
        <content type="html"><![CDATA[<h2 id="诶，还没写呢～"><a href="#诶，还没写呢～" class="headerlink" title="诶，还没写呢～"></a>诶，还没写呢～</h2>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jdk </tag>
            
            <tag> SDKMAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的注解</title>
      <link href="/JavaSE/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/50cef68448ad/"/>
      <url>/JavaSE/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/50cef68448ad/</url>
      
        <content type="html"><![CDATA[<blockquote><p>部分资料来源：<a href="http://c.biancheng.net./">http://c.biancheng.net。</a></p></blockquote><h2 id="一、注解的概念"><a href="#一、注解的概念" class="headerlink" title="一、注解的概念"></a>一、注解的概念</h2><p>从 jdk 1.5 之后可以在源代码中嵌入一些补充信息，这种补充信息称为注解（Annotation）。注解并不能改变程序的运行结果，也不会影响程序运行的性能。有些注解可以在编译时给用户提示或警告，有的注解可以在运行时读写字节码文件信息。</p><h2 id="二、注解的作用"><a href="#二、注解的作用" class="headerlink" title="二、注解的作用"></a>二、注解的作用</h2><ol><li>生成帮助文档。这是最常见的，也是 Java 最早提供的注解。常用的有 <code>@see</code>、<code>@param</code> 和 <code>@return</code> 等；</li><li>跟踪代码依赖性，实现替代配置文件功能。比较常见的是 <code>Spring 2.5</code> 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量；</li><li>在编译时进行格式检查。如把 <code>@Override</code> 注解放在方法前，如果这个方法并不是重写了父类方法，则编译时就能检查出。</li></ol><h2 id="三、常用的注解"><a href="#三、常用的注解" class="headerlink" title="三、常用的注解"></a>三、常用的注解</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在 jdk 1.8 中提供了 11 种内部注解，其中有 5 个基本注解、6 个元注解。</p><p>基本注解包括：@Override、@Deprecated、@SuppressWarnings、@SafeVarargs 和 @FunctionalInterface。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="Override-注解"><a href="#Override-注解" class="headerlink" title="@Override 注解"></a>@Override 注解</h4><p>作用目标：成员方法</p><p>作用：对方法进行对父类方法重写的检查，保证重写的一定是父类原有的方法。（重写就是子类重新定义覆盖父类原有的方法，方法签名保持一致，但其内容被改变。）</p><p>例：如下代码中是一个 <code>Person</code> 类中对 <code>toString</code> 方法的覆盖重写（<code>toString</code> 方法是 <code>Object</code> 类中的方法），如果方法签名与父类不一致，则编译会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Person.java */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">    <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Deprecated-注解"><a href="#Deprecated-注解" class="headerlink" title="@Deprecated 注解"></a>@Deprecated 注解</h4><p>作用目标：构造方法、成员变量、局部变量、方法、参数、类等</p><p>作用：用于将某个元素标记为过时的元素，使用过时的元素在编译时会给出警告。（在现代 IDE 中，如 <code>IntelliJ IDEA</code>，使用过时的元素会有删除线的效果）</p><h4 id="SuppressWarnings-注解"><a href="#SuppressWarnings-注解" class="headerlink" title="@SuppressWarnings 注解"></a>@SuppressWarnings 注解</h4><p>作用目标：构造方法、成员变量、局部变量、方法、参数、类等</p><p>作用：消除警告</p><table><thead><tr><th>关键字</th><th>用途</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td></tr><tr><td>fallthrough</td><td>抑制在 switch 中缺失 breaks 的警告</td></tr><tr><td>finally</td><td>抑制 finally 模块没有返回的警告</td></tr><tr><td>hiding</td><td>抑制相对于隐藏变量的局部变量的警告</td></tr><tr><td>incomplete-switch</td><td>忽略不完整的 switch 语句</td></tr><tr><td>nls</td><td>忽略非 nls 格式的字符</td></tr><tr><td>null</td><td>忽略对 null 的操作</td></tr><tr><td>rawtypes</td><td>使用 generics 时忽略没有指定相应的类型</td></tr><tr><td>restriction</td><td>抑制禁止使用劝阻或禁止引用的警告</td></tr><tr><td>serial</td><td>忽略在 serializable 类中没有声明 serialVersionUID 变量</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td></tr></tbody></table><p>例：消除使用过期方法的警告</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Student.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将成员方法 study() 标记为已弃用方法</span></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main.java */</span></span><br><span class="line"><span class="comment">// 将 @SuppressWarnings 注解作用在 main() 方法，使得在 main() 方法中使用已弃用方法不会得到警告</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">  student.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SafeVarargs-注解"><a href="#SafeVarargs-注解" class="headerlink" title="@SafeVarargs 注解"></a>@SafeVarargs 注解</h4><p>作用目标：构造方法、方法（不适用于非 static 或 非 final 方法，请改用 <code>@SuppressWarnings</code> 注解）</p><p>作用：消除来自形参化 vararg 类型的可能的堆污染警告</p><blockquote><p>堆污染是一个技术术语。它指的是引用的类型不是它们指向的对象的父类型。所以可能会引发异常</p></blockquote><p>例：消除可能存在堆污染的警告</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T... args)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (T arg : args) &#123;</span><br><span class="line">    <span class="comment">// 用到了一点点反射，作用是拿到 arg 的类对象，然后拿到类名。</span></span><br><span class="line">    System.out.println(arg.getClass().getName() + <span class="string">&quot;: &quot;</span> + arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FunctionalInterface-注解"><a href="#FunctionalInterface-注解" class="headerlink" title="@FunctionalInterface 注解"></a>@FunctionalInterface 注解</h4><p>作用目标：接口</p><p>作用：检查并保证该接口为函数式接口（接口中仅包含一个抽象方法，如果没有或有多个抽象方法，编译器会报错）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IFunctionalTest.java */</span></span><br><span class="line"><span class="comment">// 定义一个没啥用（仅用来测试）的函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFunctionalTest</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main.java */</span></span><br><span class="line"><span class="comment">// 用 lambda 表达式来实现接口中的抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">IFunctionalTest</span> <span class="variable">test</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">  test.test(); <span class="comment">// &quot;test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、元注解与自定义注解"><a href="#四、元注解与自定义注解" class="headerlink" title="四、元注解与自定义注解"></a>四、元注解与自定义注解</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>在 jdk 1.8 中提供了6 个元注解（元注解就是注解的注解，定义一个新注解需要用到元注解）</p><p>包括：@Documented、@Target、@Retention、@Inherited、@Repeatable 和 @Native。其中 @Repeatable 和 @Native 注解是 jdk 1.8 新增。</p><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义 */</span></span><br><span class="line">访问修饰 <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">访问修饰 类型名 成员变量名() <span class="keyword">default</span> 默认值;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">@注解名(成员变量名<span class="number">1</span> = 值<span class="number">1</span>, 成员变量名<span class="number">2</span> = 值<span class="number">2.</span>..)</span><br><span class="line">各种元素;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><strong>访问修饰符只能是 public 和 (default)(表示不写、默认，并非是关键字 default)，无论是注解还是注解的成员变量。</strong></li><li><strong>成员变量名后要加一对小括号。</strong></li><li><strong>注解的成员变量可以有默认值，通过 <code>default</code>关键字指定默认值。</strong></li><li><strong>如果注解只有一个成员变量并且名字为 <code>value</code>，那么则可以直接写成 @注解名(值) 的形式。</strong></li></ol><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>在默认情况下，<code>Java doc</code> 不会提取注解信息，但是如果声明注解时使用了 <code>@Documented</code> 注解，那么该注解就能够被 <code>Java doc</code> 提取到。</p><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p><code>@Target</code> 注解用来指定注解的作用目标，也就是该注解能够用在哪些目标下。目标有以下几种：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>CONSTRUCTOR</td><td>用于构造方法</td></tr><tr><td>FIELD</td><td>用于成员变量（包括枚举常量）</td></tr><tr><td>LOCAL_VARIABLE</td><td>用于局部变量</td></tr><tr><td>METHOD</td><td>用于方法</td></tr><tr><td>PACKAGE</td><td>用于包</td></tr><tr><td>PARAMETER</td><td>用于类型参数（JDK 1.8新增）</td></tr><tr><td>TYPE</td><td>用于类、接口（包括注解类型）或 enum 声明</td></tr></tbody></table><p>上述值是枚举类型 <code>ElementType</code> 的值，存在于 <code>java.lang.annotation</code> 包下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MyAnnotation.java */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="meta">@MyAnnotation(&quot;number&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码是 <code>@Target</code> 注解的使用示例，<code>@MyAnnotation</code> 注解适用于成员变量，如果放在其他元素上会导致编译不通过。</p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p><code>@Retention</code> 注解用于指定注解的生命周期，生命周期有以下 3 种：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>SOURCE</td><td>在资源文件中有效，注解将被编译器丢弃</td></tr><tr><td>CLASS</td><td>会被编译器记录在 .class 文件中，但在运行时不会被 VM 保留</td></tr><tr><td>RUNTIME</td><td>在运行时有效，运行时会被 VM 保留并可能被反射获取到</td></tr></tbody></table><p>上述值是枚举类型 <code>RetentionPolicy</code> 的值，同样存在于 <code>java.lang.annotation</code> 包下。</p><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p><code>@Repeatable</code> 可以使同一个注解在同一个目标上重复使用，但是需要一个容器注解配合。</p><p>在没有 <code>@Repeatable</code> 注解时在同一个目标上重复使用同一个注解：要套壳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MyAnnotation.java */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MyAnnotations.java */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line">MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="meta">@MyAnnotations(&#123;</span></span><br><span class="line"><span class="meta">@MyAnnotation(&quot;repeat&quot;),</span></span><br><span class="line"><span class="meta">@MyAnnotation(&quot;repeat&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>@Repeatable</code> 注解：可在同一目标直接上重复使用注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MyAnnotation.java */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="meta">@MyAnnotation(&quot;repeat&quot;)</span></span><br><span class="line">  <span class="meta">@MyAnnotation(&quot;repeat&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：无论有没有 <code>@Repeatable</code> 注解都需要一个容器注解用于存放注解，使用了 <code>@Repeatable</code> 注解只是在重复使用同一注解时省略了套壳而已。</strong></p><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>正常情况下，子类继承父类时，不会将作用在父类上的注解也继承过来。</p><p>而 <code>@Inherited</code> 注解的作用就是让子类继承父类的时候将注解也一并继承过来。</p><p>请看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MyAnnotation.java */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Person.java */</span></span><br><span class="line"><span class="meta">@MyAnnotation(&quot;ttt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Student.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test.java */</span></span><br><span class="line">Annotation[] annotations = Student.class.getAnnotations();</span><br><span class="line"><span class="keyword">for</span> (Annotation a : annotations) &#123;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行没有打印任何结果</span></span><br></pre></td></tr></table></figure><p>以上代码中定义了一个 <code>@MyAnnotation</code> 注解，<code>Person</code> 类和 <code>Student</code> 类，注解作用在<code>Person</code> 类上 <code>Student</code> 类继承自 <code>Person</code> 类。我们在测试代码中浅浅的使用了 Java 的反射特性来获取作用在类上的注解，但是没有任何结果，说明作用在其上的注解并没有被继承过来。</p><p>我们为 <code>@MyAnnotation</code> 注解加上 <code>@Inherited</code> 试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MyAnnotation.java */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test.java */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 运行结果：@com.jm.MyAnnotation(value=&quot;ttt&quot;)</span></span><br></pre></td></tr></table></figure><p>可以看到有结果了，打印出来了完整注解名和其中成员变量的值，说明该注解有被子类继承过来。</p><blockquote><p>反射在下一篇章，也有些书籍或教程上会先讲反射再讲注解。</p></blockquote><h4 id="Native"><a href="#Native" class="headerlink" title="@Native"></a>@Native</h4><p><code>@Native</code> 注解只适用于字段。它指示带注释的字段是可以从本机代码引用的常量。例：它在 <code>Integer</code> 类中是如何使用的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line">  <span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_VALUE</span> <span class="operator">=</span> <span class="number">0x80000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解还可以作为工具生成一些辅助头文件的提示。</p><blockquote><p>@Native 注解这段解释搬运自</p><p><a href="https://www.baeldung.com/java-default-annotations">https://www.baeldung.com/java-default-annotations</a></p><p>由于本人能力有限，实在不知道该注解的作用以及如何使用，所以就直接把该网站上对其的解释搬运过来了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS使用ssh密钥连接远程服务器</title>
      <link href="/%E5%85%B6%E4%BB%96/MacOS%E4%BD%BF%E7%94%A8ssh%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/0981664a56f1/"/>
      <url>/%E5%85%B6%E4%BB%96/MacOS%E4%BD%BF%E7%94%A8ssh%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/0981664a56f1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、在本地生成密钥"><a href="#一、在本地生成密钥" class="headerlink" title="一、在本地生成密钥"></a>一、在本地生成密钥</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><blockquote><p>一路回车就行了，ssh-keygen 在 MacOS 下会把密钥生成在 <code>/User/用户名/.ssh</code> 下</p></blockquote><h2 id="二、将公钥拷贝到服务器上"><a href="#二、将公钥拷贝到服务器上" class="headerlink" title="二、将公钥拷贝到服务器上"></a>二、将公钥拷贝到服务器上</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i /User/用户名/.ssh/id_rsa.pub root@ip</span><br></pre></td></tr></table></figure><blockquote><p>执行以上命令会要求验证，输入服务器密码就行了</p></blockquote><h2 id="三、连接"><a href="#三、连接" class="headerlink" title="三、连接"></a>三、连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@ip</span><br></pre></td></tr></table></figure><blockquote><p>可以愉快的使用了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言轻量级单元测试</title>
      <link href="/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/d553fbcb363f/"/>
      <url>/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/d553fbcb363f/</url>
      
        <content type="html"><![CDATA[<h2 id="minunit"><a href="#minunit" class="headerlink" title="minunit"></a>minunit</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>项目地址：<a href="https://github.com/siu/minunit">https://github.com/siu/minunit</a></p><p>开源协议：MIT License</p><p>一个非常轻便的、便于使用的 C 语言单元测试框架。它没有任何依赖，所有功能都以宏函数的形式放在头文件中，开箱即用。该项目的 README 中是这样描述的：</p><blockquote><p>Minunit 是一个最小的 C&#x2F;C++ 单元测试框架，独立于单个头文件中。</p><p>它提供了一种定义和配置测试套件以及一些方便的断言类型的方法。它报告运行的测试数量、断言数量和经过的时间的摘要。</p><p>请注意，该项目基于： <a href="http://www.jera.com/techinfo/jtns/jtn002.html">http://www.jera.com/techinfo/jtns/jtn002.html</a></p></blockquote><p>该项目基于 <code>John Brewer</code> 的 “C 的最小单元测试框架” MinUnit。它只有三行，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file: minunit.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mu_assert(message, test) do &#123; <span class="keyword">if</span> (!(test)) return message; &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mu_run_test(test) do &#123; char *message = test(); tests_run++; <span class="keyword">if</span> (message) return message; &#125; while (0)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> tests_run;</span><br></pre></td></tr></table></figure><p>这是一个极其简单的单元测试框架（或许不应该叫它框架），它只拥有简单的断言、运行测试用例、测试用例技术的功能。很显然，它的功能并不完善，在更大的项目中不便于使用，所以就有了本文中介绍的，更加完善，同时也保持它的轻便的 MinUnit。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="引入-MinUnit"><a href="#引入-MinUnit" class="headerlink" title="引入 MinUnit"></a>引入 MinUnit</h4><p>直接包含头文件即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minunit.h&quot;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; <span class="comment">// ... &#125;</span></span><br></pre></td></tr></table></figure><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p><strong>mu_check(condition)</strong>: 检测传入的布尔表达式是否为真，如果不为真则打印错误信息。</p><p><strong>mu_fail(message)</strong>: 手动出错，打印信息。（计入断言数量）</p><p><strong>mu_assert(test, message)</strong>: 在 <code>mu_check()</code> 的基础上加上失败打印自定义信息。</p><p><strong>mu_assert_int_eq(expected, result)</strong>: 检测返回值是否与期望值相等（整型）。</p><p><strong>mu_assert_string_eq(expected, result)</strong>: 检测返回值是否与期望值相等（字符串）。</p><p><strong>mu_assert_double_eq(expected, result)</strong>: 检测返回值是否与期望值近似（浮点型），精度阈值通过在头文件中定义的宏 <code>MINUNIT_EPSILON</code> 来控制。</p><blockquote><p>判断两个浮点数是否近似：两数之差的绝对值与阈值 <strong>EPSILON</strong> 做比较，如果它小于 <strong>EPSILON</strong> 则两数近似。</p></blockquote><h4 id="测试用例和测试组合"><a href="#测试用例和测试组合" class="headerlink" title="测试用例和测试组合"></a>测试用例和测试组合</h4><p>我们可以用 <code>MU_TEST()</code> 定义一个测试用例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MU_TEST(test_case1) &#123; <span class="comment">// ... &#125;</span></span><br></pre></td></tr></table></figure><p>实际上，上面的代码会被展开为这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">test_case1</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>MU_RUN_TEST()</code> 运行测试用例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minunit.h&quot;</span></span></span><br><span class="line">MU_TEST(test_case1) &#123; mu_check(<span class="number">5</span> == <span class="number">7</span>); &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  MU_RUN_TEST(test_case1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试组合可以用 <code>MU_TEST_SUITE()</code> 定义，一个测试组合可以将多个测试用例组合起来（其实就是一个函数里面调用了一堆函数）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MU_TEST(test_case1) &#123; mu_check(<span class="number">5</span> == <span class="number">7</span>); &#125;</span><br><span class="line">MU_TEST(test_case2) &#123; mu_check(<span class="number">5</span> != <span class="number">7</span>); &#125;</span><br><span class="line"></span><br><span class="line">MU_TEST_SUITE(test_suite1) &#123;</span><br><span class="line">  MU_RUN_TEST(test_case1);</span><br><span class="line">  MU_RUN_TEST(test_case2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>MU_RUN_SUITE()</code> 运行测试组合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minunit.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  MU_RUN_SUITE(test_suite1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="装载与卸载函数"><a href="#装载与卸载函数" class="headerlink" title="装载与卸载函数"></a>装载与卸载函数</h4><p>我们可以通过在测试组合中使用 <code>MU_SUITE_CONFIGURE()</code> 来绑定装载函数与卸载函数。装载函数和卸载函数会在运行每一个测试用例之前和之后运行，用于运行测试用例的准备工作和善后工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minunit.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_setup</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;test_setup\n&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_teardown</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;test_teardown\n&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">MU_TEST(test_case1) &#123; mu_check(<span class="number">5</span> != <span class="number">7</span>); &#125;</span><br><span class="line">MU_TEST(test_case2) &#123; mu_check(<span class="number">6</span> == <span class="number">7</span>); &#125;</span><br><span class="line"></span><br><span class="line">MU_TEST_SUITE(test_suite1) &#123;</span><br><span class="line">  MU_SUITE_CONFIGURE(&amp;test_setup, &amp;test_teardown);</span><br><span class="line">  MU_RUN_TEST(test_case1);</span><br><span class="line">  MU_RUN_TEST(test_case2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  MU_RUN_SUITE(test_suite1);</span><br><span class="line">  MU_REPORT();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在一个测试组合中运行了两个测试用例，并且绑定了装载函数和卸载函数。这两个函数会在运行每个测试用例前后运行。</p><h4 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h4><p>通过 <code>MU_REPORT()</code> 打印当前为止的测试结果报告，他将打印测试用例的个数、断言的个数和失败的个数，并计算测试完成的真实时间与处理器时间。以上代码运行结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test_setup</span><br><span class="line">.test_teardown</span><br><span class="line">test_setup</span><br><span class="line">F</span><br><span class="line">test_case2 failed:</span><br><span class="line">/Users/jm/CLionProjects/data_structure/test/llist/llist_test.c:144: 6 == 7</span><br><span class="line">test_teardown</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2 tests, 2 assertions, 1 failures</span><br><span class="line"></span><br><span class="line">Finished in 0.00004292 seconds (real) 0.00000800 seconds (proc)</span><br></pre></td></tr></table></figure><h3 id="END，可以愉快使用了！"><a href="#END，可以愉快使用了！" class="headerlink" title="END，可以愉快使用了！"></a>END，可以愉快使用了！</h3>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/uncategorized/hello-world/31284834e87b/"/>
      <url>/uncategorized/hello-world/31284834e87b/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
