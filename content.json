{"meta":{"title":"JMing's Blog","subtitle":"JMing 的个人博客","description":"法王的个人记录日常（非专业）","author":"JMing","url":"https://jm7603.github.io","root":"/"},"pages":[{"title":"关于","date":"2024-04-07T03:48:24.000Z","updated":"2024-04-07T03:49:17.166Z","comments":true,"path":"about/index.html","permalink":"https://jm7603.github.io/about/index.html","excerpt":"","text":"暂无"}],"posts":[{"title":"C++中的引用（入门）","slug":"CPP中的引用（入门）","date":"2024-05-14T13:31:48.000Z","updated":"2024-05-14T14:30:34.008Z","comments":true,"path":"CPP/CPP中的引用（入门）/58b51aa954b6/","permalink":"https://jm7603.github.io/CPP/CPP%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/58b51aa954b6/","excerpt":"","text":"C++中的引用是什么主要是用来解决指针太麻烦的问题而设计的一种新的语法格式，本质上是指针常量。 相较于指针的优缺点 优点：避免指针的麻烦写法 缺点：无法改变引用的指向、必须声明时初始化 使用引用引用的语法格式数据类型 &amp;引用名 &#x3D; 原变量; 12int a = 3;int &amp;ra = a; // 相当于 const int *ra = a; 引用的特点 必须在声明的同时初始化 123int a = 3;int &amp;ra; // ❌ declaration of reference variable &#x27;ra&#x27; requires an initializerint &amp;ra = a; // ✅ 必须保证引用类型和被引用变量的类型一致 12int a = 3;long &amp;lra = a; // ❌ non-const lvalue reference to type &#x27;long&#x27; cannot bind to a value of unrelated type &#x27;int&#x27; 不能够改变指向（不能够换绑） 123456int a = 3, b = 4;int &amp;ra = a;ra = b; // 实际上等同于 a = 4, 并不是改变指向std::cout &lt;&lt; &quot;ra: &quot; &lt;&lt; ra &lt;&lt; std::endl; // 4std::cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; std::endl; // 4std::cout &lt;&lt; &quot;b: &quot; &lt;&lt; b &lt;&lt; std::endl; // 4 引用作为函数参数例子引入：交换两变量的值 传统指针交换两个变量的值 1234567891011void SwapByPointer(int *pa, int *pb) &#123; // 需要频繁解引用，差评❌ int t = *pa; *pa = *pb; *pb = t;&#125;int main() &#123; SwapByPointer(&amp;a, &amp;b); // 传入需要加取地址符，差评❌ return 0;&#125; 引用作为函数参数交换两个变量的值 1234567891011void SwapByReference(int &amp;ra, int &amp;rb) &#123; // 可以直接当成普通变量使用，好评✅ int t = ra; ra = rb; rb = t;&#125;int main() &#123; SwapByReference(a, b); // 直接当成普通的值传入，好评✅ return 0;&#125; 例子引入：对传入字面量或常量的处理 形参为普通引用时传入字面量 12345678void PrintValue1(int &amp;ra) &#123; cout &lt;&lt; &quot;ra: &quot; &lt;&lt; ra &lt;&lt; endl;&#125;int main() &#123; PrintValue1(10); // ❌ no matching function for call to &#x27;PrintValue2&#x27; return 0;&#125; 形参为常引用时传入字面量 12345678910void PrintValue2(const int &amp;cra) &#123; cout &lt;&lt; &quot;cra: &quot; &lt;&lt; cra &lt;&lt; endl;&#125;int main() &#123; int a = 20; PrintValue2(10); // ✅ PrintValue2(a); // ✅ return 0;&#125; 原理：虽然说参数为常引用时，它本质还是指针，依然需要接收地址，但是 C++ 对策略是：当传入参数时, 如果传入的是一个右值, 那么将会有一个临时变量存放这个值, 并且引用将会绑定这个临时变量。 123// 当字面量 20 传入时, 相当于int temp = 20;const int &amp;cra = temp; 对指针的引用语法格式数据类型 *&amp;引用名 &#x3D; 原指针; 例子引入：在函数内改变指针的指向 传统二级指针 123456789void Allocate1(int **pp) &#123; *pp = new int(10);&#125;int main() &#123; int *p1 = nullptr; Allocate1(&amp;p1); return 0;&#125; 对一级指针的引用 123456789void Allocate2(int *&amp;rp) &#123; rp = new int(20);&#125;int main() &#123; int *p2 = nullptr; Allocate1(p2); return 0;&#125; 引用作为函数的返回值返回一个有效引用的前提如果要保证返回一个有效的引用，那么返回变量的生命周期必须要长于用于接收的引用，否则就是野指针。 返回引用的一些例子 局部变量作为引用返回 12345678910// a 的生命周期在函数运行结束之前, 无法被真正接收int&amp; ReturnLocalVar() &#123; int a = 10; return a;&#125;int main() &#123; int &amp;ra = ReturnLocalVar(); std::cout &lt;&lt; &quot;ra: &quot; &lt;&lt; ra &lt;&lt; std::endl; // 野指针, 乱值&#125; 静态局部变量作为引用返回 12345678910// 无论是全局还是局部的静态变量，生命周期都在程序结束之前, 可以被接收int&amp; ReturnStaticVar() &#123; static int a = 10; return a;&#125;int main() &#123; int &amp;ra = ReturnLocalVar(); std::cout &lt;&lt; &quot;ra: &quot; &lt;&lt; ra &lt;&lt; std::endl; // 10&#125; 引用参数作为返回值 12345678910111213141516// 把传进来的引用 ra 处理完再返回去int&amp; ReturnRefParam(int &amp;ra, const int value) &#123; ra = value; return ra;&#125;int main() &#123; int c = 10; int &amp;rc = ReturnRefParam(c, 20); cout &lt;&lt; &quot;rc: &quot; &lt;&lt; rc &lt;&lt; endl; // 20 // 返回的引用可作为左值, 在这里相当于 c = 40 // c 原本的值是 20, 调用函数时, 在函数内部被改为了 30, 作为引用被返回后又被赋值为 40 ReturnRefParam(c, 30) = 40; cout &lt;&lt; &quot;rc: &quot; &lt;&lt; rc &lt;&lt; endl; // 40&#125; 总结 引用的本质就是指针常量，但是对写法进行了包装，既有指针的功能，又简便了写法 引用必须在声明时初始化，且不能换绑或进行类型强转 可以对一级指针进行引用，以避免二级指针的写法，但注意声明语句的 * 一定是在 &amp; 前面 注意作为引用返回的变量的生命周期，避免野指针","categories":[{"name":"CPP","slug":"CPP","permalink":"https://jm7603.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://jm7603.github.io/tags/CPP/"},{"name":"C++","slug":"C","permalink":"https://jm7603.github.io/tags/C/"},{"name":"引用","slug":"引用","permalink":"https://jm7603.github.io/tags/%E5%BC%95%E7%94%A8/"}]},{"title":"使用SDKMAN进行jdk的版本管理","slug":"使用SDKMAN进行jdk的版本管理","date":"2024-05-11T14:11:11.000Z","updated":"2024-05-11T14:12:45.597Z","comments":true,"path":"JavaSE/使用SDKMAN进行jdk的版本管理/6442600ff246/","permalink":"https://jm7603.github.io/JavaSE/%E4%BD%BF%E7%94%A8SDKMAN%E8%BF%9B%E8%A1%8Cjdk%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/6442600ff246/","excerpt":"","text":"诶，还没写呢～","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://jm7603.github.io/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jm7603.github.io/tags/Java/"},{"name":"jdk","slug":"jdk","permalink":"https://jm7603.github.io/tags/jdk/"},{"name":"SDKMAN","slug":"SDKMAN","permalink":"https://jm7603.github.io/tags/SDKMAN/"}]},{"title":"Java中的注解","slug":"Java中的注解","date":"2024-04-09T02:00:50.000Z","updated":"2024-04-09T02:18:36.240Z","comments":true,"path":"JavaSE/Java中的注解/50cef68448ad/","permalink":"https://jm7603.github.io/JavaSE/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/50cef68448ad/","excerpt":"","text":"部分资料来源：http://c.biancheng.net。 一、注解的概念从 jdk 1.5 之后可以在源代码中嵌入一些补充信息，这种补充信息称为注解（Annotation）。注解并不能改变程序的运行结果，也不会影响程序运行的性能。有些注解可以在编译时给用户提示或警告，有的注解可以在运行时读写字节码文件信息。 二、注解的作用 生成帮助文档。这是最常见的，也是 Java 最早提供的注解。常用的有 @see、@param 和 @return 等； 跟踪代码依赖性，实现替代配置文件功能。比较常见的是 Spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量； 在编译时进行格式检查。如把 @Override 注解放在方法前，如果这个方法并不是重写了父类方法，则编译时就能检查出。 三、常用的注解简介在 jdk 1.8 中提供了 11 种内部注解，其中有 5 个基本注解、6 个元注解。 基本注解包括：@Override、@Deprecated、@SuppressWarnings、@SafeVarargs 和 @FunctionalInterface。 使用@Override 注解作用目标：成员方法 作用：对方法进行对父类方法重写的检查，保证重写的一定是父类原有的方法。（重写就是子类重新定义覆盖父类原有的方法，方法签名保持一致，但其内容被改变。） 例：如下代码中是一个 Person 类中对 toString 方法的覆盖重写（toString 方法是 Object 类中的方法），如果方法签名与父类不一致，则编译会报错。 12345678/* Person.java */@Overridepublic String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;;&#125; @Deprecated 注解作用目标：构造方法、成员变量、局部变量、方法、参数、类等 作用：用于将某个元素标记为过时的元素，使用过时的元素在编译时会给出警告。（在现代 IDE 中，如 IntelliJ IDEA，使用过时的元素会有删除线的效果） @SuppressWarnings 注解作用目标：构造方法、成员变量、局部变量、方法、参数、类等 作用：消除警告 关键字 用途 all 抑制所有警告 boxing 抑制装箱、拆箱操作时候的警告 cast 抑制映射相关的警告 dep-ann 抑制启用注释的警告 deprecation 抑制过期方法警告 fallthrough 抑制在 switch 中缺失 breaks 的警告 finally 抑制 finally 模块没有返回的警告 hiding 抑制相对于隐藏变量的局部变量的警告 incomplete-switch 忽略不完整的 switch 语句 nls 忽略非 nls 格式的字符 null 忽略对 null 的操作 rawtypes 使用 generics 时忽略没有指定相应的类型 restriction 抑制禁止使用劝阻或禁止引用的警告 serial 忽略在 serializable 类中没有声明 serialVersionUID 变量 static-access 抑制不正确的静态访问方式警告 synthetic-access 抑制子类没有按最优方法访问内部类的警告 unchecked 抑制没有进行类型检查操作的警告 unqualified-field-access 抑制没有权限访问的域的警告 unused 抑制没被使用过的代码的警告 例：消除使用过期方法的警告 1234567891011121314151617/* Student.java */public class Student extends Person &#123; // 将成员方法 study() 标记为已弃用方法 @Deprecated public void study() &#123; System.out.println(&quot;学习&quot;); &#125;&#125;/* Main.java */// 将 @SuppressWarnings 注解作用在 main() 方法，使得在 main() 方法中使用已弃用方法不会得到警告@SuppressWarnings(&quot;deprecation&quot;)public static void main(String[] args) &#123; Student student = new Student(); student.study();&#125; @SafeVarargs 注解作用目标：构造方法、方法（不适用于非 static 或 非 final 方法，请改用 @SuppressWarnings 注解） 作用：消除来自形参化 vararg 类型的可能的堆污染警告 堆污染是一个技术术语。它指的是引用的类型不是它们指向的对象的父类型。所以可能会引发异常 例：消除可能存在堆污染的警告 1234567@SafeVarargspublic static &lt;T&gt; void test(T... args) &#123; for (T arg : args) &#123; // 用到了一点点反射，作用是拿到 arg 的类对象，然后拿到类名。 System.out.println(arg.getClass().getName() + &quot;: &quot; + arg); &#125;&#125; @FunctionalInterface 注解作用目标：接口 作用：检查并保证该接口为函数式接口（接口中仅包含一个抽象方法，如果没有或有多个抽象方法，编译器会报错） 12345678910111213/* IFunctionalTest.java */// 定义一个没啥用（仅用来测试）的函数式接口@FunctionalInterfacepublic interface IFunctionalTest &#123; void test();&#125;/* Main.java */// 用 lambda 表达式来实现接口中的抽象方法public static void main(String[] args) &#123; IFunctionalTest test = () -&gt; System.out.println(&quot;test&quot;); test.test(); // &quot;test&quot;&#125; 四、元注解与自定义注解简介元注解在 jdk 1.8 中提供了6 个元注解（元注解就是注解的注解，定义一个新注解需要用到元注解） 包括：@Documented、@Target、@Retention、@Inherited、@Repeatable 和 @Native。其中 @Repeatable 和 @Native 注解是 jdk 1.8 新增。 自定义注解格式： 1234567891011/* 定义 */访问修饰 @interface 注解名 &#123; 访问修饰 类型名 成员变量名() default 默认值; ...&#125;/* 使用 */public class Test &#123; @注解名(成员变量名1 = 值1, 成员变量名2 = 值2...) 各种元素;&#125; 注意： 访问修饰符只能是 public 和 (default)(表示不写、默认，并非是关键字 default)，无论是注解还是注解的成员变量。 成员变量名后要加一对小括号。 注解的成员变量可以有默认值，通过 default关键字指定默认值。 如果注解只有一个成员变量并且名字为 value，那么则可以直接写成 @注解名(值) 的形式。 使用@Documented在默认情况下，Java doc 不会提取注解信息，但是如果声明注解时使用了 @Documented 注解，那么该注解就能够被 Java doc 提取到。 @Target@Target 注解用来指定注解的作用目标，也就是该注解能够用在哪些目标下。目标有以下几种： 名称 说明 CONSTRUCTOR 用于构造方法 FIELD 用于成员变量（包括枚举常量） LOCAL_VARIABLE 用于局部变量 METHOD 用于方法 PACKAGE 用于包 PARAMETER 用于类型参数（JDK 1.8新增） TYPE 用于类、接口（包括注解类型）或 enum 声明 上述值是枚举类型 ElementType 的值，存在于 java.lang.annotation 包下。 1234567891011/* MyAnnotation.java */@Target(ElementType.FIELD)public @interface MyAnnotation &#123; String value();&#125;/* Test.java */public class Test &#123; @MyAnnotation(&quot;number&quot;) private int number;&#125; 以上代码是 @Target 注解的使用示例，@MyAnnotation 注解适用于成员变量，如果放在其他元素上会导致编译不通过。 @Retention@Retention 注解用于指定注解的生命周期，生命周期有以下 3 种： 名称 说明 SOURCE 在资源文件中有效，注解将被编译器丢弃 CLASS 会被编译器记录在 .class 文件中，但在运行时不会被 VM 保留 RUNTIME 在运行时有效，运行时会被 VM 保留并可能被反射获取到 上述值是枚举类型 RetentionPolicy 的值，同样存在于 java.lang.annotation 包下。 @Repeatable@Repeatable 可以使同一个注解在同一个目标上重复使用，但是需要一个容器注解配合。 在没有 @Repeatable 注解时在同一个目标上重复使用同一个注解：要套壳。 12345678910111213141516171819202122/* MyAnnotation.java */@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value();&#125;/* MyAnnotations.java */@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotations &#123; MyAnnotation[] value();&#125;/* Test.java */public class Test &#123; @MyAnnotations(&#123; @MyAnnotation(&quot;repeat&quot;), @MyAnnotation(&quot;repeat&quot;) &#125;) private int number;&#125; 使用 @Repeatable 注解：可在同一目标直接上重复使用注解。 123456789101112131415/* MyAnnotation.java */@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Repeatable(MyAnnotations.class)public @interface MyAnnotation &#123; String value();&#125;/* Test.java */public class Test &#123; @MyAnnotation(&quot;repeat&quot;) @MyAnnotation(&quot;repeat&quot;) private int number;&#125; 注意：无论有没有 @Repeatable 注解都需要一个容器注解用于存放注解，使用了 @Repeatable 注解只是在重复使用同一注解时省略了套壳而已。 @Inherited正常情况下，子类继承父类时，不会将作用在父类上的注解也继承过来。 而 @Inherited 注解的作用就是让子类继承父类的时候将注解也一并继承过来。 请看以下代码： 123456789101112131415161718192021/* MyAnnotation.java */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value();&#125;/* Person.java */@MyAnnotation(&quot;ttt&quot;)public class Person &#123;&#125;/* Student.java */public class Student extends Person &#123;&#125;/* Test.java */Annotation[] annotations = Student.class.getAnnotations();for (Annotation a : annotations) &#123; System.out.println(a);&#125;// 运行没有打印任何结果 以上代码中定义了一个 @MyAnnotation 注解，Person 类和 Student 类，注解作用在Person 类上 Student 类继承自 Person 类。我们在测试代码中浅浅的使用了 Java 的反射特性来获取作用在类上的注解，但是没有任何结果，说明作用在其上的注解并没有被继承过来。 我们为 @MyAnnotation 注解加上 @Inherited 试试： 1234567891011/* MyAnnotation.java */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface MyAnnotation &#123; String value();&#125;/* Test.java */// ...// 运行结果：@com.jm.MyAnnotation(value=&quot;ttt&quot;) 可以看到有结果了，打印出来了完整注解名和其中成员变量的值，说明该注解有被子类继承过来。 反射在下一篇章，也有些书籍或教程上会先讲反射再讲注解。 @Native@Native 注解只适用于字段。它指示带注释的字段是可以从本机代码引用的常量。例：它在 Integer 类中是如何使用的: 123public final class Integer &#123; @Native public static final int MIN_VALUE = 0x80000000;&#125; 该注解还可以作为工具生成一些辅助头文件的提示。 @Native 注解这段解释搬运自 https://www.baeldung.com/java-default-annotations 由于本人能力有限，实在不知道该注解的作用以及如何使用，所以就直接把该网站上对其的解释搬运过来了","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://jm7603.github.io/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jm7603.github.io/tags/Java/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://jm7603.github.io/tags/JavaSE/"},{"name":"注解","slug":"注解","permalink":"https://jm7603.github.io/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"MacOS使用ssh密钥连接远程服务器","slug":"MacOS使用ssh密钥连接远程服务器","date":"2024-04-06T13:55:39.000Z","updated":"2024-04-06T13:58:12.603Z","comments":true,"path":"其他/MacOS使用ssh密钥连接远程服务器/0981664a56f1/","permalink":"https://jm7603.github.io/%E5%85%B6%E4%BB%96/MacOS%E4%BD%BF%E7%94%A8ssh%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/0981664a56f1/","excerpt":"","text":"一、在本地生成密钥1ssh-keygen -t rsa 一路回车就行了，ssh-keygen 在 MacOS 下会把密钥生成在 /User/用户名/.ssh 下 二、将公钥拷贝到服务器上1ssh-copy-id -i /User/用户名/.ssh/id_rsa.pub root@ip 执行以上命令会要求验证，输入服务器密码就行了 三、连接1ssh root@ip 可以愉快的使用了","categories":[{"name":"其他","slug":"其他","permalink":"https://jm7603.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://jm7603.github.io/tags/ssh/"}]},{"title":"C语言轻量级单元测试","slug":"C语言轻量级单元测试","date":"2024-04-02T04:37:45.000Z","updated":"2024-04-08T13:36:27.250Z","comments":true,"path":"C语言/C语言轻量级单元测试/d553fbcb363f/","permalink":"https://jm7603.github.io/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/d553fbcb363f/","excerpt":"","text":"minunit简介项目地址：https://github.com/siu/minunit 开源协议：MIT License 一个非常轻便的、便于使用的 C 语言单元测试框架。它没有任何依赖，所有功能都以宏函数的形式放在头文件中，开箱即用。该项目的 README 中是这样描述的： Minunit 是一个最小的 C&#x2F;C++ 单元测试框架，独立于单个头文件中。 它提供了一种定义和配置测试套件以及一些方便的断言类型的方法。它报告运行的测试数量、断言数量和经过的时间的摘要。 请注意，该项目基于： http://www.jera.com/techinfo/jtns/jtn002.html 该项目基于 John Brewer 的 “C 的最小单元测试框架” MinUnit。它只有三行，如下： 1234/* file: minunit.h */#define mu_assert(message, test) do &#123; if (!(test)) return message; &#125; while (0)#define mu_run_test(test) do &#123; char *message = test(); tests_run++; if (message) return message; &#125; while (0)extern int tests_run; 这是一个极其简单的单元测试框架（或许不应该叫它框架），它只拥有简单的断言、运行测试用例、测试用例技术的功能。很显然，它的功能并不完善，在更大的项目中不便于使用，所以就有了本文中介绍的，更加完善，同时也保持它的轻便的 MinUnit。 使用引入 MinUnit直接包含头文件即可。 123#include &quot;minunit.h&quot;// ...int main() &#123; // ... &#125; 断言mu_check(condition): 检测传入的布尔表达式是否为真，如果不为真则打印错误信息。 mu_fail(message): 手动出错，打印信息。（计入断言数量） mu_assert(test, message): 在 mu_check() 的基础上加上失败打印自定义信息。 mu_assert_int_eq(expected, result): 检测返回值是否与期望值相等（整型）。 mu_assert_string_eq(expected, result): 检测返回值是否与期望值相等（字符串）。 mu_assert_double_eq(expected, result): 检测返回值是否与期望值近似（浮点型），精度阈值通过在头文件中定义的宏 MINUNIT_EPSILON 来控制。 判断两个浮点数是否近似：两数之差的绝对值与阈值 EPSILON 做比较，如果它小于 EPSILON 则两数近似。 测试用例和测试组合我们可以用 MU_TEST() 定义一个测试用例。 1MU_TEST(test_case1) &#123; // ... &#125; 实际上，上面的代码会被展开为这样： 1static void test_case1(void) &#123;&#125; 使用 MU_RUN_TEST() 运行测试用例。 123456#include &quot;minunit.h&quot;MU_TEST(test_case1) &#123; mu_check(5 == 7); &#125;int main() &#123; MU_RUN_TEST(test_case1); return 0;&#125; 测试组合可以用 MU_TEST_SUITE() 定义，一个测试组合可以将多个测试用例组合起来（其实就是一个函数里面调用了一堆函数）。 1234567MU_TEST(test_case1) &#123; mu_check(5 == 7); &#125;MU_TEST(test_case2) &#123; mu_check(5 != 7); &#125;MU_TEST_SUITE(test_suite1) &#123; MU_RUN_TEST(test_case1); MU_RUN_TEST(test_case2);&#125; 使用 MU_RUN_SUITE() 运行测试组合。 12345#include &quot;minunit.h&quot;int main() &#123; MU_RUN_SUITE(test_suite1); return 0;&#125; 装载与卸载函数我们可以通过在测试组合中使用 MU_SUITE_CONFIGURE() 来绑定装载函数与卸载函数。装载函数和卸载函数会在运行每一个测试用例之前和之后运行，用于运行测试用例的准备工作和善后工作。 1234567891011121314151617181920#include &quot;minunit.h&quot;void test_setup(void) &#123; printf(&quot;test_setup\\n&quot;); &#125;void test_teardown(void) &#123; printf(&quot;test_teardown\\n&quot;); &#125;MU_TEST(test_case1) &#123; mu_check(5 != 7); &#125;MU_TEST(test_case2) &#123; mu_check(6 == 7); &#125;MU_TEST_SUITE(test_suite1) &#123; MU_SUITE_CONFIGURE(&amp;test_setup, &amp;test_teardown); MU_RUN_TEST(test_case1); MU_RUN_TEST(test_case2);&#125;int main() &#123; MU_RUN_SUITE(test_suite1); MU_REPORT(); return 0;&#125; 以上代码在一个测试组合中运行了两个测试用例，并且绑定了装载函数和卸载函数。这两个函数会在运行每个测试用例前后运行。 测试报告通过 MU_REPORT() 打印当前为止的测试结果报告，他将打印测试用例的个数、断言的个数和失败的个数，并计算测试完成的真实时间与处理器时间。以上代码运行结果如下： 123456789101112test_setup.test_teardowntest_setupFtest_case2 failed: /Users/jm/CLionProjects/data_structure/test/llist/llist_test.c:144: 6 == 7test_teardown2 tests, 2 assertions, 1 failuresFinished in 0.00004292 seconds (real) 0.00000800 seconds (proc) END，可以愉快使用了！","categories":[{"name":"C语言","slug":"C语言","permalink":"https://jm7603.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://jm7603.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"单元测试","slug":"单元测试","permalink":"https://jm7603.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-04-02T03:16:28.978Z","updated":"2024-04-02T03:16:28.978Z","comments":true,"path":"uncategorized/hello-world/31284834e87b/","permalink":"https://jm7603.github.io/uncategorized/hello-world/31284834e87b/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"CPP","slug":"CPP","permalink":"https://jm7603.github.io/categories/CPP/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://jm7603.github.io/categories/JavaSE/"},{"name":"其他","slug":"其他","permalink":"https://jm7603.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"C语言","slug":"C语言","permalink":"https://jm7603.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://jm7603.github.io/tags/CPP/"},{"name":"C++","slug":"C","permalink":"https://jm7603.github.io/tags/C/"},{"name":"引用","slug":"引用","permalink":"https://jm7603.github.io/tags/%E5%BC%95%E7%94%A8/"},{"name":"Java","slug":"Java","permalink":"https://jm7603.github.io/tags/Java/"},{"name":"jdk","slug":"jdk","permalink":"https://jm7603.github.io/tags/jdk/"},{"name":"SDKMAN","slug":"SDKMAN","permalink":"https://jm7603.github.io/tags/SDKMAN/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://jm7603.github.io/tags/JavaSE/"},{"name":"注解","slug":"注解","permalink":"https://jm7603.github.io/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"ssh","slug":"ssh","permalink":"https://jm7603.github.io/tags/ssh/"},{"name":"C语言","slug":"C语言","permalink":"https://jm7603.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"单元测试","slug":"单元测试","permalink":"https://jm7603.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]}