{"meta":{"title":"JMing's Blog","subtitle":"JMing 的个人博客","description":"法王的个人记录日常（非专业）","author":"JMing","url":"https://jm7603.github.io","root":"/"},"pages":[{"title":"关于","date":"2024-04-07T03:48:24.000Z","updated":"2024-04-07T03:49:17.166Z","comments":true,"path":"about/index.html","permalink":"https://jm7603.github.io/about/index.html","excerpt":"","text":"暂无"}],"posts":[{"title":"vim快速入门","slug":"vim快速入门","date":"2024-07-06T13:28:12.000Z","updated":"2024-07-06T13:30:39.834Z","comments":true,"path":"vim/vim快速入门/52e805df7a4e/","permalink":"https://jm7603.github.io/vim/vim%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/52e805df7a4e/","excerpt":"","text":"一、vim 命令常用选项 查看 vim 版本、配置文件位置及编译信息 1vim --version 打开或新编辑 123vim # 直接开始编辑(保存文件时需指定文件名)vim &lt;filename&gt; # 打开已有文件或为新文件指定文件名(文件未保存时文件还不存在)vim &lt;filelist&gt; # 打开多个文件 打开 vim 使用教程 1vimtutor 二、vim 的几种模式 命令模式(Command mode): 进入 vim 编辑器默认为此模式, 在该模式下, 键入的字符会被识别为命令 插入模式(Insert mode): 插入模式可以像其他编辑器一样插入字符, 进入插入模式底部会显示 -- INSERT -- 底线模式(Last line mode): 在命令模式下键入 : 进入底线命令模式, 会在最底部出现 :, 此时可以输入行命令 视图模式(Visual mode): 命令模式下键入 v 进入视图模式, 进入视图模式底部会显示 -- VISUAL --, 在此模式下可以移动光标对文本进行选中, 可以对选中的文本进行命令操作 三、vim 的基本使用 以下，&lt;filename&gt; 代表文件名, &lt;text&gt; 代表文本, &lt;N&gt; 代表一个数字, &lt;char&gt; 代表一个字符 退出 vim 编辑器 在未改动文件的情况下: q 在改动过文件但未保存时: q!(强制退出) 从命令模式到插入模式的几种方式 在光标前: i 在光标后: a 光标下一行: o 光标上一行: O 光标所在行尾部: A 从插入模式返回到命令模式 ESC &lt;ctrl-[&gt; &lt;ctrl-c&gt; 保存相关 文件存在或文件不存在但已指定文件名: :w 还原文件到上一次保存的状态: :e! 保存并退出 :wq :x ZZ(命令模式下) 文件不存在且未指定文件名 :w &lt;filename&gt; :wq &lt;filename&gt; x &lt;filename&gt; 移动光标 左下右上分别为: h, j, k, l 移动到行首: 0 移动到行尾: $ 移动到行首第一个非空白符: ^ 移动到行尾第一个非空白符: g_ 移动到下一个单词的开头: w 移动到下一个单词的结尾: e 移动到下一个单词的开头(紧挨在一起的非空白符识别为一个单词): W 移动到下一个单词的结尾(紧挨在一起的非空白符识别为一个单词): E 移动到相应代码块的对应括号: % 移动到光标所在行内查找到的字符的前一个字符, 向右查找: t&lt;char&gt; 移动到光标所在行内查找到的字符的前一个字符, 向左查找: T&lt;char&gt; 删除相关 删除当前光标所指字符: x 在本行内删除所有内容, 直到遇到指定字符: dt&lt;char&gt; 查看帮助文档 进入帮助文档: :help 退出帮助文档, 返回编辑器: :q 退出帮助文档同时退出编辑器: qa! 查找定位 向下查找: /&lt;text&gt; 向上查找: ?&lt;text&gt; 下一个: n 上一个: N 完整匹配光标当前所在的单词并查找下一个: * 完整匹配光标当前所在的单词并查找上一个: # 在光标所在行内查找字符, 向右查找: f&lt;char&gt; 在光标所在行内查找字符, 向左查找: F&lt;char&gt; 查找高亮: :set hlsearch 编辑器下方的 /text 或 ?text 未消失说明还在查找状态, 在查找状态可选择查找下一个或上一个 撤销与重做 撤销上一次操作: u 还原上一次撤销的操作: &lt;ctrl-r&gt; 复制相关 复制光标所在行: yy 剪切光标所在行: dd 在光标下一行插入一行并粘贴: p 将下一行的内容合并到本行: J 对原有命令进行附加操作 重复上一个改变文本的命令: . 重复某个命令 N 次: N&lt;command&gt; 重复 N 次插入操作: Ni&lt;text&gt;&lt;ctrl-c&gt;&lt;CR&gt; 跳转相关 跳转到第 N 行 &lt;N&gt;G :&lt;N&gt; 跳转到第一行: gg 跳转到最后一行: G 四、vim 进阶使用视图模式以字符为选择单位, 命令模式下键入 v 进入视图模式, 进入视图模式底部会显示 -- VISUAL -- 选择双引号之间的内容, 但不包括引号本身: vi&quot; 选择双引号之间的内容, 包括引号本身: va&quot; 选择括号之间的内容, 但不包括括号本身: vi) 选择括号之间的内容, 包括括号本身: va)&quot; … (只要是成对的符号都可以这样操作) 行视图模式以行作为选择单位, 在命令模式下键入 V 进入行视图模式, 进入行视图模式底部会显示 -- VISUAL LINE -- 块视图模式可以进行矩形(块)选择, &lt;ctrl-v&gt; 进入块视图模式, 进入块视图模式底部会显示 -- VISUAL BLOCK -- 在块视图模式下键入 I 可以进入块插入模式, 可以对选择的块以行为单位进行批量插入 自动补全在插入模式下, 键入&lt;ctrl-n&gt;, ctrl-p 可以进行自动补全, &lt;ctrl-n&gt; 为选中下一个补全项, &lt;ctrl-p&gt; 为选中上一个补全项 快速缩进进入视图模式后, 可以键入 = 将选中的内容自动缩进 多文件与分屏 上下分屏: :sp 左右分屏: :vs 在不同的分屏中跳转: &lt;ctrl-w&gt;*2 在本分屏中载入文件: :b &lt;filename&gt; 五、vim 的配置文件不同配置文件的位置与区别 系统配置文件: /etc/.vimrc 用户配置文件: ~/.vimrc 注意: 系统配置文件对所有用户生效, 用户配置文件仅对当前用户生效, 用户配置文件对于当前用户来说优先级较高, 所以在系统配置文件中我们一般只设置公共配置或不进行配置 六、vim 常用配置视觉相关 显示行号: set number 查找高亮: set hlsearch 成对匹配的符号高亮: set showmatch 当前行高亮: set cursorline 列高亮: set colorcolumn=82(个人习惯 82) 缩进相关 自动缩进: set autoindent 根据文件其他地方推测一个 tab 为几个空格: set starttab 缩进量: set shiftwidth=2 缩进及退格所缩进或删除的空格数: set softtabstop=2 使用空格缩进: set expandtab 查找相关 查找时忽略大小写: set ignorecase 输入搜索时就高亮显示: set incsearch 七、vim 安装插件安装 coc.nvim暂未开始 到此还未结束, 本文档将不定时更新written by jm","categories":[{"name":"vim","slug":"vim","permalink":"https://jm7603.github.io/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://jm7603.github.io/tags/vim/"},{"name":"linux","slug":"linux","permalink":"https://jm7603.github.io/tags/linux/"}]},{"title":"C++中的命名空间","slug":"CPP中的命名空间","date":"2024-05-20T11:08:00.000Z","updated":"2024-05-20T12:07:23.807Z","comments":true,"path":"CPP/CPP中的命名空间/d563b29f47f2/","permalink":"https://jm7603.github.io/CPP/CPP%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/d563b29f47f2/","excerpt":"","text":"什么是命名空间命名空间是用于表示一组标识符的可见范围，用于解决标识符重定义的问题。 命名空间的使用例子引入我们正在进行多人开发或大项目开发时，可能会出现标识符重定义的问题，也就是变量名、函数名、类名可能会存在重复的问题。 1234567891011/* file_a.cpp */#include &lt;iostream&gt;void SayHello() &#123; std::cout &lt;&lt; &quot;Hello. I am JM&quot; &lt;&lt; std::endl;&#125;int main() &#123; SayHello(); return 0;&#125; 123456/* file_b.cpp */#include &lt;iostream&gt;void SayHello() &#123; std::cout &lt;&lt; &quot;Hello. I am AA&quot; &lt;&lt; std::endl;&#125; 可以看到 file_a.cpp 和 file_b.cpp 中同时出现了同名函数且不构成函数重载。 如果我们此时进行编译的话会不通过，会出现链接错误并提示你: duplicate symbols。 虽然这个例子举得可能不恰当，似乎并不会有人这样做，但是相信我，你一定会出现类似问题的，这也是命名空间存在的意义。 命名空间的语法 声明一个命名空间 namespace 命名空间名 &#123; /\\* some identifiers \\*/ &#125; 12345namespace ns &#123;int a = 10;class ClassA &#123;&#125;void A() &#123;&#125;&#125; 访问命名空间中的内容 命名空间名::标识符 12345#include &lt;iostream&gt;int main() &#123; std::cout &lt;&lt; ns::a &lt;&lt; std::endl; // 10 return 0;&#125; 使用 using 使用命名空间我们可以使用 using 关键字使用命名空间，使得命名空间中的内容在此作用域内可见，从而不需要通过作用域运算符访问命名空间中的内容。 使用整个命名空间 using namespace 命名空间名; 1234567891011121314151617#include &lt;iostream&gt;namespace aaa &#123;int a = 10;int b = 20;&#125;/* 使用了 std 和 aaa 两个命名空间 */using namespace std;using namespace aaa;int main() &#123; /* 下面两条语句的效果相同 */ std::cout &lt;&lt; aaa::a &lt;&lt; aaa::b &lt;&lt; std::endl; cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; return 0;&#125; 使用命名空间中的部分内容 using 命名空间名::标识符; 1234567891011121314151617181920#include &lt;iostream&gt;namespace aaa &#123;int a = 10;int b = 20;&#125;/* 使用了 std 中的 cout 与 endl */using std::cout, std::endl;/* 使用了 aaa 中的 a */using aaa:a;int main() &#123; std::cout &lt;&lt; aaa::a &lt;&lt; aaa::b &lt;&lt; std::endl; /* 并没有使用 aaa 中的 b，所以还需要使用作用域运算符访问 */ cout &lt;&lt; a &lt;&lt; aaa::b &lt;&lt; endl; return 0;&#125; 在定义和使用命名空间时的注意点 命名空间的大括号后面不需要分号结束。 命名空间内的缩进可以根据个人喜好或公司代码规范来调整。 可以在一个文件内出现多个命名空间，也可以在多个文件内出现同一个名字的命名空间，但同名命名空间内绝对不能出现重名的标识符。 一个文件出现多个命名空间 ✅ 123456789101112#include &lt;iostream&gt;namespace aaa &#123;int a = 10;&#125;namespace bbb &#123;int a = 20;&#125;int main() &#123; std::cout &lt;&lt; aaa:a &lt;&lt; endl; // 10 std::cout &lt;&lt; bbb:a &lt;&lt; endl; // 20&#125; 多个文件中出现同一个名字的命名空间 ✅ 1234/* file_a.cpp */namespace aaa &#123;int a = 10;&#125; 1234/* file_b.cpp */namespace aaa &#123;int b = 20;&#125; 这样做并不好，因为这样虽然编译能通过，但是在 file_a.cpp 中并不能够访问到 file_b.cpp 中的那部分。 所以正确的做法是将它们放在不同的头文件中来方便我们引入，如果你需要在命名空间中存放的内容并不多，且内容同属一个模块，那么直接放在一个文件中即可。 多个文件中出现同一个名字的命名空间，并出现了重名的标识符 ❌ 12345/* file_a.cpp *//* 错误示范 */namespace aaa &#123;int a = 10;&#125; 12345/* file_b.cpp *//* 错误示范 */namespace aaa &#123;int a = 20;&#125; 这样做就等同于在一个作用域内声明&#x2F;定义了同名标识符 12345/* 错误示范 */namespace aaa &#123;int a = 10;int a = 20;&#125; 在 using 命名空间时，也请保证在一个作用域内不会出现可见的多个同名标识符，否则编译不通过，出现链接错误。","categories":[{"name":"CPP","slug":"CPP","permalink":"https://jm7603.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://jm7603.github.io/tags/CPP/"},{"name":"C++","slug":"C","permalink":"https://jm7603.github.io/tags/C/"},{"name":"namespace","slug":"namespace","permalink":"https://jm7603.github.io/tags/namespace/"}]},{"title":"C++中的引用（入门）","slug":"CPP中的引用（入门）","date":"2024-05-14T13:31:48.000Z","updated":"2024-05-14T14:35:03.169Z","comments":true,"path":"CPP/CPP中的引用（入门）/58b51aa954b6/","permalink":"https://jm7603.github.io/CPP/CPP%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/58b51aa954b6/","excerpt":"","text":"C++中的引用是什么主要是用来解决指针太麻烦的问题而设计的一种新的语法格式，本质上是指针常量。 相较于指针的优缺点 优点：避免指针的麻烦写法 缺点：无法改变引用的指向、必须声明时初始化 使用引用引用的语法格式数据类型 &amp;引用名 &#x3D; 原变量; 12int a = 3;int &amp;ra = a; // 相当于 const int *ra = a; 引用的特点 必须在声明的同时初始化 123int a = 3;int &amp;ra; // ❌ declaration of reference variable &#x27;ra&#x27; requires an initializerint &amp;ra = a; // ✅ 必须保证引用类型和被引用变量的类型一致 12int a = 3;long &amp;lra = a; // ❌ non-const lvalue reference to type &#x27;long&#x27; cannot bind to a value of unrelated type &#x27;int&#x27; 不能够改变指向（不能够换绑） 123456int a = 3, b = 4;int &amp;ra = a;ra = b; // 实际上等同于 a = 4, 并不是改变指向std::cout &lt;&lt; &quot;ra: &quot; &lt;&lt; ra &lt;&lt; std::endl; // 4std::cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; std::endl; // 4std::cout &lt;&lt; &quot;b: &quot; &lt;&lt; b &lt;&lt; std::endl; // 4 引用作为函数参数例子引入：交换两变量的值 传统指针交换两个变量的值 1234567891011void SwapByPointer(int *pa, int *pb) &#123; // 需要频繁解引用，差评❌ int t = *pa; *pa = *pb; *pb = t;&#125;int main() &#123; SwapByPointer(&amp;a, &amp;b); // 传入需要加取地址符，差评❌ return 0;&#125; 引用作为函数参数交换两个变量的值 1234567891011void SwapByReference(int &amp;ra, int &amp;rb) &#123; // 可以直接当成普通变量使用，好评✅ int t = ra; ra = rb; rb = t;&#125;int main() &#123; SwapByReference(a, b); // 直接当成普通的值传入，好评✅ return 0;&#125; 例子引入：对传入字面量或常量的处理 形参为普通引用时传入字面量 12345678void PrintValue1(int &amp;ra) &#123; cout &lt;&lt; &quot;ra: &quot; &lt;&lt; ra &lt;&lt; endl;&#125;int main() &#123; PrintValue1(10); // ❌ no matching function for call to &#x27;PrintValue2&#x27; return 0;&#125; 形参为常引用时传入字面量 12345678910void PrintValue2(const int &amp;cra) &#123; cout &lt;&lt; &quot;cra: &quot; &lt;&lt; cra &lt;&lt; endl;&#125;int main() &#123; int a = 20; PrintValue2(10); // ✅ PrintValue2(a); // ✅ return 0;&#125; 原理：虽然说参数为常引用时，它本质还是指针，依然需要接收地址，但是 C++ 对策略是：当传入参数时, 如果传入的是一个右值, 那么将会有一个临时变量存放这个值, 并且引用将会绑定这个临时变量。 123// 当字面量 20 传入时, 相当于int temp = 20;const int &amp;cra = temp; 对指针的引用语法格式数据类型 *&amp;引用名 &#x3D; 原指针; 例子引入：在函数内改变指针的指向 传统二级指针 123456789void Allocate1(int **pp) &#123; *pp = new int(10);&#125;int main() &#123; int *p1 = nullptr; Allocate1(&amp;p1); return 0;&#125; 对一级指针的引用 123456789void Allocate2(int *&amp;rp) &#123; rp = new int(20);&#125;int main() &#123; int *p2 = nullptr; Allocate1(p2); return 0;&#125; 引用作为函数的返回值返回一个有效引用的前提如果要保证返回一个有效的引用，那么返回变量的生命周期必须要长于用于接收的引用，否则就是野指针。 返回引用的一些例子 局部变量作为引用返回 12345678910// a 的生命周期在函数运行结束之前, 无法被真正接收int&amp; ReturnLocalVar() &#123; int a = 10; return a;&#125;int main() &#123; int &amp;ra = ReturnLocalVar(); std::cout &lt;&lt; &quot;ra: &quot; &lt;&lt; ra &lt;&lt; std::endl; // 野指针, 乱值&#125; 静态局部变量作为引用返回 12345678910// 无论是全局还是局部的静态变量，生命周期都在程序结束之前, 可以被接收int&amp; ReturnStaticVar() &#123; static int a = 10; return a;&#125;int main() &#123; int &amp;ra = ReturnLocalVar(); std::cout &lt;&lt; &quot;ra: &quot; &lt;&lt; ra &lt;&lt; std::endl; // 10&#125; 引用参数作为返回值 12345678910111213141516// 把传进来的引用 ra 处理完再返回去int&amp; ReturnRefParam(int &amp;ra, const int value) &#123; ra = value; return ra;&#125;int main() &#123; int c = 10; int &amp;rc = ReturnRefParam(c, 20); cout &lt;&lt; &quot;rc: &quot; &lt;&lt; rc &lt;&lt; endl; // 20 // 返回的引用可作为左值, 在这里相当于 c = 40 // c 原本的值是 20, 调用函数时, 在函数内部被改为了 30, 作为引用被返回后又被赋值为 40 ReturnRefParam(c, 30) = 40; cout &lt;&lt; &quot;rc: &quot; &lt;&lt; rc &lt;&lt; endl; // 40&#125; 总结 引用的本质就是指针常量，但是对写法进行了包装，既有指针的功能，又简便了写法 引用必须在声明时初始化，且不能换绑或进行类型强转 可以对一级指针进行引用，以避免二级指针的写法，但注意声明语句的 * 一定是在 &amp; 前面 注意作为引用返回的变量的生命周期，避免野指针","categories":[{"name":"CPP","slug":"CPP","permalink":"https://jm7603.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://jm7603.github.io/tags/CPP/"},{"name":"C++","slug":"C","permalink":"https://jm7603.github.io/tags/C/"},{"name":"引用","slug":"引用","permalink":"https://jm7603.github.io/tags/%E5%BC%95%E7%94%A8/"}]},{"title":"使用SDKMAN进行jdk的版本管理","slug":"使用SDKMAN进行jdk的版本管理","date":"2024-05-11T14:11:11.000Z","updated":"2024-05-11T14:12:45.597Z","comments":true,"path":"JavaSE/使用SDKMAN进行jdk的版本管理/6442600ff246/","permalink":"https://jm7603.github.io/JavaSE/%E4%BD%BF%E7%94%A8SDKMAN%E8%BF%9B%E8%A1%8Cjdk%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/6442600ff246/","excerpt":"","text":"诶，还没写呢～","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://jm7603.github.io/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jm7603.github.io/tags/Java/"},{"name":"jdk","slug":"jdk","permalink":"https://jm7603.github.io/tags/jdk/"},{"name":"SDKMAN","slug":"SDKMAN","permalink":"https://jm7603.github.io/tags/SDKMAN/"}]},{"title":"Java中的注解","slug":"Java中的注解","date":"2024-04-09T02:00:50.000Z","updated":"2024-04-09T02:18:36.240Z","comments":true,"path":"JavaSE/Java中的注解/50cef68448ad/","permalink":"https://jm7603.github.io/JavaSE/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/50cef68448ad/","excerpt":"","text":"部分资料来源：http://c.biancheng.net。 一、注解的概念从 jdk 1.5 之后可以在源代码中嵌入一些补充信息，这种补充信息称为注解（Annotation）。注解并不能改变程序的运行结果，也不会影响程序运行的性能。有些注解可以在编译时给用户提示或警告，有的注解可以在运行时读写字节码文件信息。 二、注解的作用 生成帮助文档。这是最常见的，也是 Java 最早提供的注解。常用的有 @see、@param 和 @return 等； 跟踪代码依赖性，实现替代配置文件功能。比较常见的是 Spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量； 在编译时进行格式检查。如把 @Override 注解放在方法前，如果这个方法并不是重写了父类方法，则编译时就能检查出。 三、常用的注解简介在 jdk 1.8 中提供了 11 种内部注解，其中有 5 个基本注解、6 个元注解。 基本注解包括：@Override、@Deprecated、@SuppressWarnings、@SafeVarargs 和 @FunctionalInterface。 使用@Override 注解作用目标：成员方法 作用：对方法进行对父类方法重写的检查，保证重写的一定是父类原有的方法。（重写就是子类重新定义覆盖父类原有的方法，方法签名保持一致，但其内容被改变。） 例：如下代码中是一个 Person 类中对 toString 方法的覆盖重写（toString 方法是 Object 类中的方法），如果方法签名与父类不一致，则编译会报错。 12345678/* Person.java */@Overridepublic String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;;&#125; @Deprecated 注解作用目标：构造方法、成员变量、局部变量、方法、参数、类等 作用：用于将某个元素标记为过时的元素，使用过时的元素在编译时会给出警告。（在现代 IDE 中，如 IntelliJ IDEA，使用过时的元素会有删除线的效果） @SuppressWarnings 注解作用目标：构造方法、成员变量、局部变量、方法、参数、类等 作用：消除警告 关键字 用途 all 抑制所有警告 boxing 抑制装箱、拆箱操作时候的警告 cast 抑制映射相关的警告 dep-ann 抑制启用注释的警告 deprecation 抑制过期方法警告 fallthrough 抑制在 switch 中缺失 breaks 的警告 finally 抑制 finally 模块没有返回的警告 hiding 抑制相对于隐藏变量的局部变量的警告 incomplete-switch 忽略不完整的 switch 语句 nls 忽略非 nls 格式的字符 null 忽略对 null 的操作 rawtypes 使用 generics 时忽略没有指定相应的类型 restriction 抑制禁止使用劝阻或禁止引用的警告 serial 忽略在 serializable 类中没有声明 serialVersionUID 变量 static-access 抑制不正确的静态访问方式警告 synthetic-access 抑制子类没有按最优方法访问内部类的警告 unchecked 抑制没有进行类型检查操作的警告 unqualified-field-access 抑制没有权限访问的域的警告 unused 抑制没被使用过的代码的警告 例：消除使用过期方法的警告 1234567891011121314151617/* Student.java */public class Student extends Person &#123; // 将成员方法 study() 标记为已弃用方法 @Deprecated public void study() &#123; System.out.println(&quot;学习&quot;); &#125;&#125;/* Main.java */// 将 @SuppressWarnings 注解作用在 main() 方法，使得在 main() 方法中使用已弃用方法不会得到警告@SuppressWarnings(&quot;deprecation&quot;)public static void main(String[] args) &#123; Student student = new Student(); student.study();&#125; @SafeVarargs 注解作用目标：构造方法、方法（不适用于非 static 或 非 final 方法，请改用 @SuppressWarnings 注解） 作用：消除来自形参化 vararg 类型的可能的堆污染警告 堆污染是一个技术术语。它指的是引用的类型不是它们指向的对象的父类型。所以可能会引发异常 例：消除可能存在堆污染的警告 1234567@SafeVarargspublic static &lt;T&gt; void test(T... args) &#123; for (T arg : args) &#123; // 用到了一点点反射，作用是拿到 arg 的类对象，然后拿到类名。 System.out.println(arg.getClass().getName() + &quot;: &quot; + arg); &#125;&#125; @FunctionalInterface 注解作用目标：接口 作用：检查并保证该接口为函数式接口（接口中仅包含一个抽象方法，如果没有或有多个抽象方法，编译器会报错） 12345678910111213/* IFunctionalTest.java */// 定义一个没啥用（仅用来测试）的函数式接口@FunctionalInterfacepublic interface IFunctionalTest &#123; void test();&#125;/* Main.java */// 用 lambda 表达式来实现接口中的抽象方法public static void main(String[] args) &#123; IFunctionalTest test = () -&gt; System.out.println(&quot;test&quot;); test.test(); // &quot;test&quot;&#125; 四、元注解与自定义注解简介元注解在 jdk 1.8 中提供了6 个元注解（元注解就是注解的注解，定义一个新注解需要用到元注解） 包括：@Documented、@Target、@Retention、@Inherited、@Repeatable 和 @Native。其中 @Repeatable 和 @Native 注解是 jdk 1.8 新增。 自定义注解格式： 1234567891011/* 定义 */访问修饰 @interface 注解名 &#123; 访问修饰 类型名 成员变量名() default 默认值; ...&#125;/* 使用 */public class Test &#123; @注解名(成员变量名1 = 值1, 成员变量名2 = 值2...) 各种元素;&#125; 注意： 访问修饰符只能是 public 和 (default)(表示不写、默认，并非是关键字 default)，无论是注解还是注解的成员变量。 成员变量名后要加一对小括号。 注解的成员变量可以有默认值，通过 default关键字指定默认值。 如果注解只有一个成员变量并且名字为 value，那么则可以直接写成 @注解名(值) 的形式。 使用@Documented在默认情况下，Java doc 不会提取注解信息，但是如果声明注解时使用了 @Documented 注解，那么该注解就能够被 Java doc 提取到。 @Target@Target 注解用来指定注解的作用目标，也就是该注解能够用在哪些目标下。目标有以下几种： 名称 说明 CONSTRUCTOR 用于构造方法 FIELD 用于成员变量（包括枚举常量） LOCAL_VARIABLE 用于局部变量 METHOD 用于方法 PACKAGE 用于包 PARAMETER 用于类型参数（JDK 1.8新增） TYPE 用于类、接口（包括注解类型）或 enum 声明 上述值是枚举类型 ElementType 的值，存在于 java.lang.annotation 包下。 1234567891011/* MyAnnotation.java */@Target(ElementType.FIELD)public @interface MyAnnotation &#123; String value();&#125;/* Test.java */public class Test &#123; @MyAnnotation(&quot;number&quot;) private int number;&#125; 以上代码是 @Target 注解的使用示例，@MyAnnotation 注解适用于成员变量，如果放在其他元素上会导致编译不通过。 @Retention@Retention 注解用于指定注解的生命周期，生命周期有以下 3 种： 名称 说明 SOURCE 在资源文件中有效，注解将被编译器丢弃 CLASS 会被编译器记录在 .class 文件中，但在运行时不会被 VM 保留 RUNTIME 在运行时有效，运行时会被 VM 保留并可能被反射获取到 上述值是枚举类型 RetentionPolicy 的值，同样存在于 java.lang.annotation 包下。 @Repeatable@Repeatable 可以使同一个注解在同一个目标上重复使用，但是需要一个容器注解配合。 在没有 @Repeatable 注解时在同一个目标上重复使用同一个注解：要套壳。 12345678910111213141516171819202122/* MyAnnotation.java */@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value();&#125;/* MyAnnotations.java */@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotations &#123; MyAnnotation[] value();&#125;/* Test.java */public class Test &#123; @MyAnnotations(&#123; @MyAnnotation(&quot;repeat&quot;), @MyAnnotation(&quot;repeat&quot;) &#125;) private int number;&#125; 使用 @Repeatable 注解：可在同一目标直接上重复使用注解。 123456789101112131415/* MyAnnotation.java */@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Repeatable(MyAnnotations.class)public @interface MyAnnotation &#123; String value();&#125;/* Test.java */public class Test &#123; @MyAnnotation(&quot;repeat&quot;) @MyAnnotation(&quot;repeat&quot;) private int number;&#125; 注意：无论有没有 @Repeatable 注解都需要一个容器注解用于存放注解，使用了 @Repeatable 注解只是在重复使用同一注解时省略了套壳而已。 @Inherited正常情况下，子类继承父类时，不会将作用在父类上的注解也继承过来。 而 @Inherited 注解的作用就是让子类继承父类的时候将注解也一并继承过来。 请看以下代码： 123456789101112131415161718192021/* MyAnnotation.java */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123; String value();&#125;/* Person.java */@MyAnnotation(&quot;ttt&quot;)public class Person &#123;&#125;/* Student.java */public class Student extends Person &#123;&#125;/* Test.java */Annotation[] annotations = Student.class.getAnnotations();for (Annotation a : annotations) &#123; System.out.println(a);&#125;// 运行没有打印任何结果 以上代码中定义了一个 @MyAnnotation 注解，Person 类和 Student 类，注解作用在Person 类上 Student 类继承自 Person 类。我们在测试代码中浅浅的使用了 Java 的反射特性来获取作用在类上的注解，但是没有任何结果，说明作用在其上的注解并没有被继承过来。 我们为 @MyAnnotation 注解加上 @Inherited 试试： 1234567891011/* MyAnnotation.java */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface MyAnnotation &#123; String value();&#125;/* Test.java */// ...// 运行结果：@com.jm.MyAnnotation(value=&quot;ttt&quot;) 可以看到有结果了，打印出来了完整注解名和其中成员变量的值，说明该注解有被子类继承过来。 反射在下一篇章，也有些书籍或教程上会先讲反射再讲注解。 @Native@Native 注解只适用于字段。它指示带注释的字段是可以从本机代码引用的常量。例：它在 Integer 类中是如何使用的: 123public final class Integer &#123; @Native public static final int MIN_VALUE = 0x80000000;&#125; 该注解还可以作为工具生成一些辅助头文件的提示。 @Native 注解这段解释搬运自 https://www.baeldung.com/java-default-annotations 由于本人能力有限，实在不知道该注解的作用以及如何使用，所以就直接把该网站上对其的解释搬运过来了","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://jm7603.github.io/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jm7603.github.io/tags/Java/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://jm7603.github.io/tags/JavaSE/"},{"name":"注解","slug":"注解","permalink":"https://jm7603.github.io/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"MacOS使用ssh密钥连接远程服务器","slug":"MacOS使用ssh密钥连接远程服务器","date":"2024-04-06T13:55:39.000Z","updated":"2024-04-06T13:58:12.603Z","comments":true,"path":"其他/MacOS使用ssh密钥连接远程服务器/0981664a56f1/","permalink":"https://jm7603.github.io/%E5%85%B6%E4%BB%96/MacOS%E4%BD%BF%E7%94%A8ssh%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/0981664a56f1/","excerpt":"","text":"一、在本地生成密钥1ssh-keygen -t rsa 一路回车就行了，ssh-keygen 在 MacOS 下会把密钥生成在 /User/用户名/.ssh 下 二、将公钥拷贝到服务器上1ssh-copy-id -i /User/用户名/.ssh/id_rsa.pub root@ip 执行以上命令会要求验证，输入服务器密码就行了 三、连接1ssh root@ip 可以愉快的使用了","categories":[{"name":"其他","slug":"其他","permalink":"https://jm7603.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://jm7603.github.io/tags/ssh/"}]},{"title":"C语言轻量级单元测试","slug":"C语言轻量级单元测试","date":"2024-04-02T04:37:45.000Z","updated":"2024-04-08T13:36:27.250Z","comments":true,"path":"C语言/C语言轻量级单元测试/d553fbcb363f/","permalink":"https://jm7603.github.io/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/d553fbcb363f/","excerpt":"","text":"minunit简介项目地址：https://github.com/siu/minunit 开源协议：MIT License 一个非常轻便的、便于使用的 C 语言单元测试框架。它没有任何依赖，所有功能都以宏函数的形式放在头文件中，开箱即用。该项目的 README 中是这样描述的： Minunit 是一个最小的 C&#x2F;C++ 单元测试框架，独立于单个头文件中。 它提供了一种定义和配置测试套件以及一些方便的断言类型的方法。它报告运行的测试数量、断言数量和经过的时间的摘要。 请注意，该项目基于： http://www.jera.com/techinfo/jtns/jtn002.html 该项目基于 John Brewer 的 “C 的最小单元测试框架” MinUnit。它只有三行，如下： 1234/* file: minunit.h */#define mu_assert(message, test) do &#123; if (!(test)) return message; &#125; while (0)#define mu_run_test(test) do &#123; char *message = test(); tests_run++; if (message) return message; &#125; while (0)extern int tests_run; 这是一个极其简单的单元测试框架（或许不应该叫它框架），它只拥有简单的断言、运行测试用例、测试用例技术的功能。很显然，它的功能并不完善，在更大的项目中不便于使用，所以就有了本文中介绍的，更加完善，同时也保持它的轻便的 MinUnit。 使用引入 MinUnit直接包含头文件即可。 123#include &quot;minunit.h&quot;// ...int main() &#123; // ... &#125; 断言mu_check(condition): 检测传入的布尔表达式是否为真，如果不为真则打印错误信息。 mu_fail(message): 手动出错，打印信息。（计入断言数量） mu_assert(test, message): 在 mu_check() 的基础上加上失败打印自定义信息。 mu_assert_int_eq(expected, result): 检测返回值是否与期望值相等（整型）。 mu_assert_string_eq(expected, result): 检测返回值是否与期望值相等（字符串）。 mu_assert_double_eq(expected, result): 检测返回值是否与期望值近似（浮点型），精度阈值通过在头文件中定义的宏 MINUNIT_EPSILON 来控制。 判断两个浮点数是否近似：两数之差的绝对值与阈值 EPSILON 做比较，如果它小于 EPSILON 则两数近似。 测试用例和测试组合我们可以用 MU_TEST() 定义一个测试用例。 1MU_TEST(test_case1) &#123; // ... &#125; 实际上，上面的代码会被展开为这样： 1static void test_case1(void) &#123;&#125; 使用 MU_RUN_TEST() 运行测试用例。 123456#include &quot;minunit.h&quot;MU_TEST(test_case1) &#123; mu_check(5 == 7); &#125;int main() &#123; MU_RUN_TEST(test_case1); return 0;&#125; 测试组合可以用 MU_TEST_SUITE() 定义，一个测试组合可以将多个测试用例组合起来（其实就是一个函数里面调用了一堆函数）。 1234567MU_TEST(test_case1) &#123; mu_check(5 == 7); &#125;MU_TEST(test_case2) &#123; mu_check(5 != 7); &#125;MU_TEST_SUITE(test_suite1) &#123; MU_RUN_TEST(test_case1); MU_RUN_TEST(test_case2);&#125; 使用 MU_RUN_SUITE() 运行测试组合。 12345#include &quot;minunit.h&quot;int main() &#123; MU_RUN_SUITE(test_suite1); return 0;&#125; 装载与卸载函数我们可以通过在测试组合中使用 MU_SUITE_CONFIGURE() 来绑定装载函数与卸载函数。装载函数和卸载函数会在运行每一个测试用例之前和之后运行，用于运行测试用例的准备工作和善后工作。 1234567891011121314151617181920#include &quot;minunit.h&quot;void test_setup(void) &#123; printf(&quot;test_setup\\n&quot;); &#125;void test_teardown(void) &#123; printf(&quot;test_teardown\\n&quot;); &#125;MU_TEST(test_case1) &#123; mu_check(5 != 7); &#125;MU_TEST(test_case2) &#123; mu_check(6 == 7); &#125;MU_TEST_SUITE(test_suite1) &#123; MU_SUITE_CONFIGURE(&amp;test_setup, &amp;test_teardown); MU_RUN_TEST(test_case1); MU_RUN_TEST(test_case2);&#125;int main() &#123; MU_RUN_SUITE(test_suite1); MU_REPORT(); return 0;&#125; 以上代码在一个测试组合中运行了两个测试用例，并且绑定了装载函数和卸载函数。这两个函数会在运行每个测试用例前后运行。 测试报告通过 MU_REPORT() 打印当前为止的测试结果报告，他将打印测试用例的个数、断言的个数和失败的个数，并计算测试完成的真实时间与处理器时间。以上代码运行结果如下： 123456789101112test_setup.test_teardowntest_setupFtest_case2 failed: /Users/jm/CLionProjects/data_structure/test/llist/llist_test.c:144: 6 == 7test_teardown2 tests, 2 assertions, 1 failuresFinished in 0.00004292 seconds (real) 0.00000800 seconds (proc) END，可以愉快使用了！","categories":[{"name":"C语言","slug":"C语言","permalink":"https://jm7603.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://jm7603.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"单元测试","slug":"单元测试","permalink":"https://jm7603.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-04-02T03:16:28.978Z","updated":"2024-04-02T03:16:28.978Z","comments":true,"path":"uncategorized/hello-world/31284834e87b/","permalink":"https://jm7603.github.io/uncategorized/hello-world/31284834e87b/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"vim","slug":"vim","permalink":"https://jm7603.github.io/categories/vim/"},{"name":"CPP","slug":"CPP","permalink":"https://jm7603.github.io/categories/CPP/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://jm7603.github.io/categories/JavaSE/"},{"name":"其他","slug":"其他","permalink":"https://jm7603.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"C语言","slug":"C语言","permalink":"https://jm7603.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://jm7603.github.io/tags/vim/"},{"name":"linux","slug":"linux","permalink":"https://jm7603.github.io/tags/linux/"},{"name":"CPP","slug":"CPP","permalink":"https://jm7603.github.io/tags/CPP/"},{"name":"C++","slug":"C","permalink":"https://jm7603.github.io/tags/C/"},{"name":"namespace","slug":"namespace","permalink":"https://jm7603.github.io/tags/namespace/"},{"name":"引用","slug":"引用","permalink":"https://jm7603.github.io/tags/%E5%BC%95%E7%94%A8/"},{"name":"Java","slug":"Java","permalink":"https://jm7603.github.io/tags/Java/"},{"name":"jdk","slug":"jdk","permalink":"https://jm7603.github.io/tags/jdk/"},{"name":"SDKMAN","slug":"SDKMAN","permalink":"https://jm7603.github.io/tags/SDKMAN/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://jm7603.github.io/tags/JavaSE/"},{"name":"注解","slug":"注解","permalink":"https://jm7603.github.io/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"ssh","slug":"ssh","permalink":"https://jm7603.github.io/tags/ssh/"},{"name":"C语言","slug":"C语言","permalink":"https://jm7603.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"单元测试","slug":"单元测试","permalink":"https://jm7603.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]}